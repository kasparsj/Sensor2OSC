// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pftp_request.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Query types (SAGRFC53).
/// Query parameters, if any, are transmitted in the following data (SAGRFC56)
/// and defined below, individually per query type. Responses to queries are
/// defined in pftp_response.proto.
public enum Protocol_PbPFtpQuery: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case identifyDevice // = 0
  case setSystemTime // = 1
  case getSystemTime // = 2
  case setLocalTime // = 3
  case getLocalTime // = 4
  case getDiskSpace // = 5
  case generateChallengeToken // = 6
  case setInternalTest // = 7
  case getBatteryStatus // = 8
  case setAdbMode // = 9
  case cleanupDiskSpace // = 10
  case getInactivityPreAlert // = 11
  case prepareFirmwareUpdate // = 12
  case requestSynchronization // = 13
  case requestStartRecording // = 14
  case requestStopRecording // = 15
  case requestRecordingStatus // = 16
  case generateAsymmetricKeys // = 17
  case getDisplayStatus // = 18
  case getVisualElements // = 19

  public init() {
    self = .identifyDevice
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .identifyDevice
    case 1: self = .setSystemTime
    case 2: self = .getSystemTime
    case 3: self = .setLocalTime
    case 4: self = .getLocalTime
    case 5: self = .getDiskSpace
    case 6: self = .generateChallengeToken
    case 7: self = .setInternalTest
    case 8: self = .getBatteryStatus
    case 9: self = .setAdbMode
    case 10: self = .cleanupDiskSpace
    case 11: self = .getInactivityPreAlert
    case 12: self = .prepareFirmwareUpdate
    case 13: self = .requestSynchronization
    case 14: self = .requestStartRecording
    case 15: self = .requestStopRecording
    case 16: self = .requestRecordingStatus
    case 17: self = .generateAsymmetricKeys
    case 18: self = .getDisplayStatus
    case 19: self = .getVisualElements
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .identifyDevice: return 0
    case .setSystemTime: return 1
    case .getSystemTime: return 2
    case .setLocalTime: return 3
    case .getLocalTime: return 4
    case .getDiskSpace: return 5
    case .generateChallengeToken: return 6
    case .setInternalTest: return 7
    case .getBatteryStatus: return 8
    case .setAdbMode: return 9
    case .cleanupDiskSpace: return 10
    case .getInactivityPreAlert: return 11
    case .prepareFirmwareUpdate: return 12
    case .requestSynchronization: return 13
    case .requestStartRecording: return 14
    case .requestStopRecording: return 15
    case .requestRecordingStatus: return 16
    case .generateAsymmetricKeys: return 17
    case .getDisplayStatus: return 18
    case .getVisualElements: return 19
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPFtpQuery: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Class for PFTP filesystem operation and its parameters.
/// - For GET, ending directory delimiter in path designates directory listing operation. Otherwise, it's a read file operation.
/// - For PUT, ending directory delimiter in path designates directory creation. Otherwise, it's a write file operation.
/// - For PUT (when writing a file) and MERGE operations, the file is transmitted in following data.
/// - Other than PUT (when writing a file) and MERGE operations do not required additional data, only the path parameter.
/// - See SAGRFC56 for details.
public struct Protocol_PbPFtpOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File operation command. The format of the path parameter affect to the command behavior. See SAGRFC56.
  public var command: Protocol_PbPFtpOperation.Command {
    get {return _command ?? .get}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {self._command = nil}

  /// Path to the target file or directory. Ending directory delimiter designates directory. See SAGRFC56.
  public var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Command: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case put // = 1
    case merge // = 2
    case remove // = 3

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .put
      case 2: self = .merge
      case 3: self = .remove
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .put: return 1
      case .merge: return 2
      case .remove: return 3
      }
    }

  }

  public init() {}

  fileprivate var _command: Protocol_PbPFtpOperation.Command? = nil
  fileprivate var _path: String? = nil
}

#if swift(>=4.2)

extension Protocol_PbPFtpOperation.Command: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Parameters for SET_SYSTEM_TIME query.
public struct Protocol_PbPFtpSetSystemTimeParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UTC date to be set.
  public var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// UTC time to be set.
  public var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// True, if date and time are from trusted source.
  public var trusted: Bool {
    get {return _trusted ?? false}
    set {_trusted = newValue}
  }
  /// Returns true if `trusted` has been explicitly set.
  public var hasTrusted: Bool {return self._trusted != nil}
  /// Clears the value of `trusted`. Subsequent reads from it will return its default value.
  public mutating func clearTrusted() {self._trusted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _trusted: Bool? = nil
}

///
/// Parameters for REQUEST_START_RECORDING query.
public struct Protocol_PbPFtpRequestStartRecordingParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sampleType: PbSampleType {
    get {return _sampleType ?? .sampleTypeUndefined}
    set {_sampleType = newValue}
  }
  /// Returns true if `sampleType` has been explicitly set.
  public var hasSampleType: Bool {return self._sampleType != nil}
  /// Clears the value of `sampleType`. Subsequent reads from it will return its default value.
  public mutating func clearSampleType() {self._sampleType = nil}

  public var recordingInterval: PbDuration {
    get {return _recordingInterval ?? PbDuration()}
    set {_recordingInterval = newValue}
  }
  /// Returns true if `recordingInterval` has been explicitly set.
  public var hasRecordingInterval: Bool {return self._recordingInterval != nil}
  /// Clears the value of `recordingInterval`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingInterval() {self._recordingInterval = nil}

  public var sampleDataIdentifier: String {
    get {return _sampleDataIdentifier ?? String()}
    set {_sampleDataIdentifier = newValue}
  }
  /// Returns true if `sampleDataIdentifier` has been explicitly set.
  public var hasSampleDataIdentifier: Bool {return self._sampleDataIdentifier != nil}
  /// Clears the value of `sampleDataIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearSampleDataIdentifier() {self._sampleDataIdentifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sampleType: PbSampleType? = nil
  fileprivate var _recordingInterval: PbDuration? = nil
  fileprivate var _sampleDataIdentifier: String? = nil
}

///
/// Parameters for SET_LOCAL_TIME query.
public struct Protocol_PbPFtpSetLocalTimeParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Local date to be set.
  public var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// Local time to be set.
  public var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// If present (known), timezone offset in 1 minute precision (-12h = -720min to +14h = +840min).
  public var tzOffset: Int32 {
    get {return _tzOffset ?? 0}
    set {_tzOffset = newValue}
  }
  /// Returns true if `tzOffset` has been explicitly set.
  public var hasTzOffset: Bool {return self._tzOffset != nil}
  /// Clears the value of `tzOffset`. Subsequent reads from it will return its default value.
  public mutating func clearTzOffset() {self._tzOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _tzOffset: Int32? = nil
}

///
/// Parameters for GENERATE_CHALLENGE_TOKEN query.
public struct Protocol_PbPFtpGenerateChallengeTokenParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User's local id.
  public var userID: UInt32 {
    get {return _userID ?? 0}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// Exactly 16 bytes of random nonse.
  public var nonse: Data {
    get {return _nonse ?? Data()}
    set {_nonse = newValue}
  }
  /// Returns true if `nonse` has been explicitly set.
  public var hasNonse: Bool {return self._nonse != nil}
  /// Clears the value of `nonse`. Subsequent reads from it will return its default value.
  public mutating func clearNonse() {self._nonse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: UInt32? = nil
  fileprivate var _nonse: Data? = nil
}

///
/// Parameters for SET_ADB_MODE query.
public struct Protocol_PbPFtpSetAdbModeParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enable / disable adb mode
  public var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  public var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  public mutating func clearEnable() {self._enable = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _enable: Bool? = nil
}

///
/// Parameters for CLEANUP_DISK_SPACE query.
public struct Protocol_PbPFtpCleanupDiskSpaceParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of required free space in bytes
  public var requiredBytes: UInt64 {
    get {return _requiredBytes ?? 0}
    set {_requiredBytes = newValue}
  }
  /// Returns true if `requiredBytes` has been explicitly set.
  public var hasRequiredBytes: Bool {return self._requiredBytes != nil}
  /// Clears the value of `requiredBytes`. Subsequent reads from it will return its default value.
  public mutating func clearRequiredBytes() {self._requiredBytes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requiredBytes: UInt64? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_PbPFtpQuery: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDENTIFY_DEVICE"),
    1: .same(proto: "SET_SYSTEM_TIME"),
    2: .same(proto: "GET_SYSTEM_TIME"),
    3: .same(proto: "SET_LOCAL_TIME"),
    4: .same(proto: "GET_LOCAL_TIME"),
    5: .same(proto: "GET_DISK_SPACE"),
    6: .same(proto: "GENERATE_CHALLENGE_TOKEN"),
    7: .same(proto: "SET_INTERNAL_TEST"),
    8: .same(proto: "GET_BATTERY_STATUS"),
    9: .same(proto: "SET_ADB_MODE"),
    10: .same(proto: "CLEANUP_DISK_SPACE"),
    11: .same(proto: "GET_INACTIVITY_PRE_ALERT"),
    12: .same(proto: "PREPARE_FIRMWARE_UPDATE"),
    13: .same(proto: "REQUEST_SYNCHRONIZATION"),
    14: .same(proto: "REQUEST_START_RECORDING"),
    15: .same(proto: "REQUEST_STOP_RECORDING"),
    16: .same(proto: "REQUEST_RECORDING_STATUS"),
    17: .same(proto: "GENERATE_ASYMMETRIC_KEYS"),
    18: .same(proto: "GET_DISPLAY_STATUS"),
    19: .same(proto: "GET_VISUAL_ELEMENTS"),
  ]
}

extension Protocol_PbPFtpOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "path"),
  ]

  public var isInitialized: Bool {
    if self._command == nil {return false}
    if self._path == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpOperation, rhs: Protocol_PbPFtpOperation) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpOperation.Command: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "PUT"),
    2: .same(proto: "MERGE"),
    3: .same(proto: "REMOVE"),
  ]
}

extension Protocol_PbPFtpSetSystemTimeParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpSetSystemTimeParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .same(proto: "trusted"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if self._trusted == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._trusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._trusted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpSetSystemTimeParams, rhs: Protocol_PbPFtpSetSystemTimeParams) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._trusted != rhs._trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpRequestStartRecordingParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpRequestStartRecordingParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .standard(proto: "recording_interval"),
    3: .standard(proto: "sample_data_identifier"),
  ]

  public var isInitialized: Bool {
    if self._sampleType == nil {return false}
    if self._recordingInterval == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recordingInterval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sampleDataIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recordingInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sampleDataIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpRequestStartRecordingParams, rhs: Protocol_PbPFtpRequestStartRecordingParams) -> Bool {
    if lhs._sampleType != rhs._sampleType {return false}
    if lhs._recordingInterval != rhs._recordingInterval {return false}
    if lhs._sampleDataIdentifier != rhs._sampleDataIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSetLocalTimeParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpSetLocalTimeParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .standard(proto: "tz_offset"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._tzOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tzOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpSetLocalTimeParams, rhs: Protocol_PbPFtpSetLocalTimeParams) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._tzOffset != rhs._tzOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateChallengeTokenParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGenerateChallengeTokenParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "nonse"),
  ]

  public var isInitialized: Bool {
    if self._userID == nil {return false}
    if self._nonse == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._nonse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nonse {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGenerateChallengeTokenParams, rhs: Protocol_PbPFtpGenerateChallengeTokenParams) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._nonse != rhs._nonse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSetAdbModeParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpSetAdbModeParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public var isInitialized: Bool {
    if self._enable == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpSetAdbModeParams, rhs: Protocol_PbPFtpSetAdbModeParams) -> Bool {
    if lhs._enable != rhs._enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpCleanupDiskSpaceParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpCleanupDiskSpaceParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_bytes"),
  ]

  public var isInitialized: Bool {
    if self._requiredBytes == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requiredBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requiredBytes {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpCleanupDiskSpaceParams, rhs: Protocol_PbPFtpCleanupDiskSpaceParams) -> Bool {
    if lhs._requiredBytes != rhs._requiredBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
