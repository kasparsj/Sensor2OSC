// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pftp_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Class for presenting filesystem entry, i.e. file or directory.
/// - The entry is directory if the name ends to directory delimiter, i.e. '/' character. F.ex. "directory/" or "directory.ext/".
/// - Otherwise the entry is considered to be a file. F.ex. "file" or "file.ext".
/// - See PbPFtpDirectory below for response to a directory listing operation.
public struct Protocol_PbPFtpEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file or directory. Ending directory delimiter designates directory entry.
  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  /// Size of the file in bytes, or 0 for directory entry.
  public var size: UInt64 {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {_uniqueStorage()._size = nil}

  /// If present, entry's creation date/time. I.e. instant of the first write.
  public var created: PbSystemDateTime {
    get {return _storage._created ?? PbSystemDateTime()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// If present, entry's last modified date/time.  I.e. instant of the last write.
  public var modified: PbSystemDateTime {
    get {return _storage._modified ?? PbSystemDateTime()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  /// If present, entry's last touched date/time. I.e. instant of the last read or write.
  public var touched: PbSystemDateTime {
    get {return _storage._touched ?? PbSystemDateTime()}
    set {_uniqueStorage()._touched = newValue}
  }
  /// Returns true if `touched` has been explicitly set.
  public var hasTouched: Bool {return _storage._touched != nil}
  /// Clears the value of `touched`. Subsequent reads from it will return its default value.
  public mutating func clearTouched() {_uniqueStorage()._touched = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Response to GET directory list operation.
/// The PbPFtpDirectory message is to be transmitted in the response data (SAGRFC56).
public struct Protocol_PbPFtpDirectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of unique entries in a directory.
  public var entries: [Protocol_PbPFtpEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Response data to IDENTIFY_DEVICE query in pftp_request.proto.
public struct Protocol_PbPFtpIdentifyDeviceResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device's id (SAGRFC19).
  public var deviceID: String {
    get {return _deviceID ?? String()}
    set {_deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  public var hasDeviceID: Bool {return self._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceID() {self._deviceID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceID: String? = nil
}

///
/// Response data to GET_SYSTEM_TIME query in pftp_request.proto.
public struct Protocol_PbPFtpGetSystemTimeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UTC date.
  public var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// UTC time.
  public var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// True, if the date and time can be trusted.
  public var trusted: Bool {
    get {return _trusted ?? false}
    set {_trusted = newValue}
  }
  /// Returns true if `trusted` has been explicitly set.
  public var hasTrusted: Bool {return self._trusted != nil}
  /// Clears the value of `trusted`. Subsequent reads from it will return its default value.
  public mutating func clearTrusted() {self._trusted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _trusted: Bool? = nil
}

///
/// Response data to GET_LOCAL_TIME query in pftp_request.proto.
public struct Protocol_PbPFtpGetLocalTimeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Local date.
  public var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// Local time.
  public var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// If present, timezone offset in 1 minute precision (-12h = -720min to +12h = +720min).
  public var tzOffset: Int32 {
    get {return _tzOffset ?? 0}
    set {_tzOffset = newValue}
  }
  /// Returns true if `tzOffset` has been explicitly set.
  public var hasTzOffset: Bool {return self._tzOffset != nil}
  /// Clears the value of `tzOffset`. Subsequent reads from it will return its default value.
  public mutating func clearTzOffset() {self._tzOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _tzOffset: Int32? = nil
}

///
/// Response data to GET_DISK_SPACE and CLEANUP_DISK_SPACE queries in pftp_request.proto.
public struct Protocol_PbPFtpDiskSpaceResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filesystem fragment size. Smallest allocatable filesystem unit.
  public var fragmentSize: UInt32 {
    get {return _fragmentSize ?? 0}
    set {_fragmentSize = newValue}
  }
  /// Returns true if `fragmentSize` has been explicitly set.
  public var hasFragmentSize: Bool {return self._fragmentSize != nil}
  /// Clears the value of `fragmentSize`. Subsequent reads from it will return its default value.
  public mutating func clearFragmentSize() {self._fragmentSize = nil}

  /// Total size of the filesystem in fragments.
  public var totalFragments: UInt64 {
    get {return _totalFragments ?? 0}
    set {_totalFragments = newValue}
  }
  /// Returns true if `totalFragments` has been explicitly set.
  public var hasTotalFragments: Bool {return self._totalFragments != nil}
  /// Clears the value of `totalFragments`. Subsequent reads from it will return its default value.
  public mutating func clearTotalFragments() {self._totalFragments = nil}

  /// Amount of available fragments.
  public var freeFragments: UInt64 {
    get {return _freeFragments ?? 0}
    set {_freeFragments = newValue}
  }
  /// Returns true if `freeFragments` has been explicitly set.
  public var hasFreeFragments: Bool {return self._freeFragments != nil}
  /// Clears the value of `freeFragments`. Subsequent reads from it will return its default value.
  public mutating func clearFreeFragments() {self._freeFragments = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fragmentSize: UInt32? = nil
  fileprivate var _totalFragments: UInt64? = nil
  fileprivate var _freeFragments: UInt64? = nil
}

///
/// Response data to GENERATE_CHALLENGE_TOKEN query in pftp_request.proto.
public struct Protocol_PbPFtpGenerateChallengeTokenResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Generated challenge token. Exactly 16 bytes.
  public var token: Data {
    get {return _token ?? Data()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Data? = nil
}

///
/// Response data to GENERATE_ASYMMETRIC_KEYS query in pftp_request.proto.
public struct Protocol_PbPFtpGenerateAsymmetricKeysResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Generated public key, can only be created once.
  ///For Bugatti/Macan first byte is 0x01, Remaining 33 bytes contain sec256k1 public key in compressed format.
  ///same data is also saved to file /SYS/KEYS/PUBLIC
  public var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  ///asymmetric_key_format defines the format of the public_key
  public var asymmetricKeyFormat: Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat {
    get {return _asymmetricKeyFormat ?? .sec256KlCompressed}
    set {_asymmetricKeyFormat = newValue}
  }
  /// Returns true if `asymmetricKeyFormat` has been explicitly set.
  public var hasAsymmetricKeyFormat: Bool {return self._asymmetricKeyFormat != nil}
  /// Clears the value of `asymmetricKeyFormat`. Subsequent reads from it will return its default value.
  public mutating func clearAsymmetricKeyFormat() {self._asymmetricKeyFormat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PbAsymmetricKeyFormat: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    ///For Bugatti/Macan first byte is 0x01, Remaining 33 bytes contain sec256k1 public key in compressed format.
    case sec256KlCompressed // = 0

    public init() {
      self = .sec256KlCompressed
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sec256KlCompressed
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .sec256KlCompressed: return 0
      }
    }

  }

  public init() {}

  fileprivate var _publicKey: Data? = nil
  fileprivate var _asymmetricKeyFormat: Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat? = nil
}

#if swift(>=4.2)

extension Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Response data to GET_BATTERY_STATUS query in pftp_request.proto and used as
/// parameters in BATTERY_STATUS notification defined in pftp_notification.proto.
public struct Protocol_PbPFtpBatteryStatusResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Battery status in percentage
  /// Range [0-100%] 
  public var batteryStatus: UInt32 {
    get {return _batteryStatus ?? 0}
    set {_batteryStatus = newValue}
  }
  /// Returns true if `batteryStatus` has been explicitly set.
  public var hasBatteryStatus: Bool {return self._batteryStatus != nil}
  /// Clears the value of `batteryStatus`. Subsequent reads from it will return its default value.
  public mutating func clearBatteryStatus() {self._batteryStatus = nil}

  public var charging: Bool {
    get {return _charging ?? false}
    set {_charging = newValue}
  }
  /// Returns true if `charging` has been explicitly set.
  public var hasCharging: Bool {return self._charging != nil}
  /// Clears the value of `charging`. Subsequent reads from it will return its default value.
  public mutating func clearCharging() {self._charging = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batteryStatus: UInt32? = nil
  fileprivate var _charging: Bool? = nil
}

///
/// Response data to GET_INACTIVITY_PRE_ALERT query in pftp_request.proto.
public struct Protocol_PbPFtpGetInactivityPreAlertResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True, if inactivity pre-alert has triggered. False after pre-alert's time window has expired.
  public var inactivityPreAlertOn: Bool {
    get {return _inactivityPreAlertOn ?? false}
    set {_inactivityPreAlertOn = newValue}
  }
  /// Returns true if `inactivityPreAlertOn` has been explicitly set.
  public var hasInactivityPreAlertOn: Bool {return self._inactivityPreAlertOn != nil}
  /// Clears the value of `inactivityPreAlertOn`. Subsequent reads from it will return its default value.
  public mutating func clearInactivityPreAlertOn() {self._inactivityPreAlertOn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inactivityPreAlertOn: Bool? = nil
}

/// 
/// Response data to REQUEST_RECORDING_STATUS query in pftp_request.proto.
public struct Protocol_PbRequestRecordingStatusResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var recordingOn: Bool {
    get {return _recordingOn ?? false}
    set {_recordingOn = newValue}
  }
  /// Returns true if `recordingOn` has been explicitly set.
  public var hasRecordingOn: Bool {return self._recordingOn != nil}
  /// Clears the value of `recordingOn`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingOn() {self._recordingOn = nil}

  public var sampleDataIdentifier: String {
    get {return _sampleDataIdentifier ?? String()}
    set {_sampleDataIdentifier = newValue}
  }
  /// Returns true if `sampleDataIdentifier` has been explicitly set.
  public var hasSampleDataIdentifier: Bool {return self._sampleDataIdentifier != nil}
  /// Clears the value of `sampleDataIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearSampleDataIdentifier() {self._sampleDataIdentifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _recordingOn: Bool? = nil
  fileprivate var _sampleDataIdentifier: String? = nil
}

/// 
/// Response data to GET_DISPLAY_STATUS query in pftp_request.proto.
public struct Protocol_PbRequestDisplayStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayOn: Bool {
    get {return _displayOn ?? false}
    set {_displayOn = newValue}
  }
  /// Returns true if `displayOn` has been explicitly set.
  public var hasDisplayOn: Bool {return self._displayOn != nil}
  /// Clears the value of `displayOn`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayOn() {self._displayOn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _displayOn: Bool? = nil
}

///
/// Response data to GET_VISUAL_ELEMENTS query in pftp_request.proto.
public struct Protocol_PbPFtpGetVisualElementsResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to visual elements data file.
  public var visualDataPath: String {
    get {return _visualDataPath ?? String()}
    set {_visualDataPath = newValue}
  }
  /// Returns true if `visualDataPath` has been explicitly set.
  public var hasVisualDataPath: Bool {return self._visualDataPath != nil}
  /// Clears the value of `visualDataPath`. Subsequent reads from it will return its default value.
  public mutating func clearVisualDataPath() {self._visualDataPath = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _visualDataPath: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_PbPFtpEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "size"),
    3: .same(proto: "created"),
    4: .same(proto: "modified"),
    5: .same(proto: "touched"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _size: UInt64? = nil
    var _created: PbSystemDateTime? = nil
    var _modified: PbSystemDateTime? = nil
    var _touched: PbSystemDateTime? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _size = source._size
      _created = source._created
      _modified = source._modified
      _touched = source._touched
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if _storage._size == nil {return false}
      if let v = _storage._created, !v.isInitialized {return false}
      if let v = _storage._modified, !v.isInitialized {return false}
      if let v = _storage._touched, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._size) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._modified) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._touched) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._touched {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpEntry, rhs: Protocol_PbPFtpEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._modified != rhs_storage._modified {return false}
        if _storage._touched != rhs_storage._touched {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpDirectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpDirectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpDirectory, rhs: Protocol_PbPFtpDirectory) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpIdentifyDeviceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpIdentifyDeviceResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  public var isInitialized: Bool {
    if self._deviceID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpIdentifyDeviceResult, rhs: Protocol_PbPFtpIdentifyDeviceResult) -> Bool {
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetSystemTimeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGetSystemTimeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .same(proto: "trusted"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if self._trusted == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._trusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._trusted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGetSystemTimeResult, rhs: Protocol_PbPFtpGetSystemTimeResult) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._trusted != rhs._trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetLocalTimeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGetLocalTimeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .standard(proto: "tz_offset"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._tzOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tzOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGetLocalTimeResult, rhs: Protocol_PbPFtpGetLocalTimeResult) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._tzOffset != rhs._tzOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpDiskSpaceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpDiskSpaceResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fragment_size"),
    2: .standard(proto: "total_fragments"),
    3: .standard(proto: "free_fragments"),
  ]

  public var isInitialized: Bool {
    if self._fragmentSize == nil {return false}
    if self._totalFragments == nil {return false}
    if self._freeFragments == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._fragmentSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._totalFragments) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._freeFragments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fragmentSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalFragments {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._freeFragments {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpDiskSpaceResult, rhs: Protocol_PbPFtpDiskSpaceResult) -> Bool {
    if lhs._fragmentSize != rhs._fragmentSize {return false}
    if lhs._totalFragments != rhs._totalFragments {return false}
    if lhs._freeFragments != rhs._freeFragments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateChallengeTokenResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGenerateChallengeTokenResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public var isInitialized: Bool {
    if self._token == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGenerateChallengeTokenResult, rhs: Protocol_PbPFtpGenerateChallengeTokenResult) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateAsymmetricKeysResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGenerateAsymmetricKeysResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "asymmetric_key_format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._asymmetricKeyFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asymmetricKeyFormat {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGenerateAsymmetricKeysResult, rhs: Protocol_PbPFtpGenerateAsymmetricKeysResult) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._asymmetricKeyFormat != rhs._asymmetricKeyFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEC256KL_COMPRESSED"),
  ]
}

extension Protocol_PbPFtpBatteryStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpBatteryStatusResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "battery_status"),
    2: .same(proto: "charging"),
  ]

  public var isInitialized: Bool {
    if self._batteryStatus == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._batteryStatus) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._charging) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batteryStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._charging {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpBatteryStatusResult, rhs: Protocol_PbPFtpBatteryStatusResult) -> Bool {
    if lhs._batteryStatus != rhs._batteryStatus {return false}
    if lhs._charging != rhs._charging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetInactivityPreAlertResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGetInactivityPreAlertResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inactivity_pre_alert_on"),
  ]

  public var isInitialized: Bool {
    if self._inactivityPreAlertOn == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._inactivityPreAlertOn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inactivityPreAlertOn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGetInactivityPreAlertResult, rhs: Protocol_PbPFtpGetInactivityPreAlertResult) -> Bool {
    if lhs._inactivityPreAlertOn != rhs._inactivityPreAlertOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbRequestRecordingStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbRequestRecordingStatusResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recording_on"),
    2: .standard(proto: "sample_data_identifier"),
  ]

  public var isInitialized: Bool {
    if self._recordingOn == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._recordingOn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sampleDataIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recordingOn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sampleDataIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbRequestRecordingStatusResult, rhs: Protocol_PbRequestRecordingStatusResult) -> Bool {
    if lhs._recordingOn != rhs._recordingOn {return false}
    if lhs._sampleDataIdentifier != rhs._sampleDataIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbRequestDisplayStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbRequestDisplayStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_on"),
  ]

  public var isInitialized: Bool {
    if self._displayOn == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._displayOn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayOn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbRequestDisplayStatus, rhs: Protocol_PbRequestDisplayStatus) -> Bool {
    if lhs._displayOn != rhs._displayOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetVisualElementsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGetVisualElementsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visual_data_path"),
  ]

  public var isInitialized: Bool {
    if self._visualDataPath == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._visualDataPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._visualDataPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGetVisualElementsResult, rhs: Protocol_PbPFtpGetVisualElementsResult) -> Bool {
    if lhs._visualDataPath != rhs._visualDataPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
