// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: structures.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// products
public struct PbVolumeTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Exercise target type
  public var targetType: PbVolumeTarget.PbVolymeTargetType {
    get {return _targetType ?? .volumeTargetTypeDuration}
    set {_targetType = newValue}
  }
  /// Returns true if `targetType` has been explicitly set.
  public var hasTargetType: Bool {return self._targetType != nil}
  /// Clears the value of `targetType`. Subsequent reads from it will return its default value.
  public mutating func clearTargetType() {self._targetType = nil}

  /// Duration target
  public var duration: PbDuration {
    get {return _duration ?? PbDuration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// Distance target
  public var distance: Float {
    get {return _distance ?? 0}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  public var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  public mutating func clearDistance() {self._distance = nil}

  /// Calories target
  public var calories: UInt32 {
    get {return _calories ?? 0}
    set {_calories = newValue}
  }
  /// Returns true if `calories` has been explicitly set.
  public var hasCalories: Bool {return self._calories != nil}
  /// Clears the value of `calories`. Subsequent reads from it will return its default value.
  public mutating func clearCalories() {self._calories = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PbVolymeTargetType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case volumeTargetTypeDuration // = 0
    case volumeTargetTypeDistance // = 1
    case volumeTargetTypeCalories // = 2

    public init() {
      self = .volumeTargetTypeDuration
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .volumeTargetTypeDuration
      case 1: self = .volumeTargetTypeDistance
      case 2: self = .volumeTargetTypeCalories
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .volumeTargetTypeDuration: return 0
      case .volumeTargetTypeDistance: return 1
      case .volumeTargetTypeCalories: return 2
      }
    }

  }

  public init() {}

  fileprivate var _targetType: PbVolumeTarget.PbVolymeTargetType? = nil
  fileprivate var _duration: PbDuration? = nil
  fileprivate var _distance: Float? = nil
  fileprivate var _calories: UInt32? = nil
}

#if swift(>=4.2)

extension PbVolumeTarget.PbVolymeTargetType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct PbStravaSegmentTargets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Own best time
  public var ownBest: PbDuration {
    get {return _ownBest ?? PbDuration()}
    set {_ownBest = newValue}
  }
  /// Returns true if `ownBest` has been explicitly set.
  public var hasOwnBest: Bool {return self._ownBest != nil}
  /// Clears the value of `ownBest`. Subsequent reads from it will return its default value.
  public mutating func clearOwnBest() {self._ownBest = nil}

  /// King or Queen of the Mountain
  public var komQom: PbDuration {
    get {return _komQom ?? PbDuration()}
    set {_komQom = newValue}
  }
  /// Returns true if `komQom` has been explicitly set.
  public var hasKomQom: Bool {return self._komQom != nil}
  /// Clears the value of `komQom`. Subsequent reads from it will return its default value.
  public mutating func clearKomQom() {self._komQom = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ownBest: PbDuration? = nil
  fileprivate var _komQom: PbDuration? = nil
}

public struct PbStravaSegmentTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SNIPER GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH
  public var stravaSegmentType: PbStravaSegmentTarget.PbStravaSegmentType {
    get {return _stravaSegmentType ?? .stravaSegmentTypeRide}
    set {_stravaSegmentType = newValue}
  }
  /// Returns true if `stravaSegmentType` has been explicitly set.
  public var hasStravaSegmentType: Bool {return self._stravaSegmentType != nil}
  /// Clears the value of `stravaSegmentType`. Subsequent reads from it will return its default value.
  public mutating func clearStravaSegmentType() {self._stravaSegmentType = nil}

  /// SNIPER GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH
  public var stravaSegmentTargets: PbStravaSegmentTargets {
    get {return _stravaSegmentTargets ?? PbStravaSegmentTargets()}
    set {_stravaSegmentTargets = newValue}
  }
  /// Returns true if `stravaSegmentTargets` has been explicitly set.
  public var hasStravaSegmentTargets: Bool {return self._stravaSegmentTargets != nil}
  /// Clears the value of `stravaSegmentTargets`. Subsequent reads from it will return its default value.
  public mutating func clearStravaSegmentTargets() {self._stravaSegmentTargets = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PbStravaSegmentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case stravaSegmentTypeRide // = 1
    case stravaSegmentTypeRun // = 2

    public init() {
      self = .stravaSegmentTypeRide
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .stravaSegmentTypeRide
      case 2: self = .stravaSegmentTypeRun
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .stravaSegmentTypeRide: return 1
      case .stravaSegmentTypeRun: return 2
      }
    }

  }

  public init() {}

  fileprivate var _stravaSegmentType: PbStravaSegmentTarget.PbStravaSegmentType? = nil
  fileprivate var _stravaSegmentTargets: PbStravaSegmentTargets? = nil
}

#if swift(>=4.2)

extension PbStravaSegmentTarget.PbStravaSegmentType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct PbFuelingReminder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time when reminder was given to user (since start of training session)
  public var timestamp: PbDuration {
    get {return _timestamp ?? PbDuration()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Type of reminder
  public var fuelingReminderType: PbFuelingReminder.PbFuelingReminderType {
    get {return _fuelingReminderType ?? .reminderTypeEnergyManual}
    set {_fuelingReminderType = newValue}
  }
  /// Returns true if `fuelingReminderType` has been explicitly set.
  public var hasFuelingReminderType: Bool {return self._fuelingReminderType != nil}
  /// Clears the value of `fuelingReminderType`. Subsequent reads from it will return its default value.
  public mutating func clearFuelingReminderType() {self._fuelingReminderType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// There are 3 types of reminders - energy and hydration (drinking) reminder
  /// can be given at the same time
  public enum PbFuelingReminderType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case reminderTypeEnergyManual // = 1
    case reminderTypeEnergySmart // = 2
    case reminderTypeHydration // = 3
    case reminderTypeHydrationAndEnergyManual // = 4
    case reminderTypeHydrationAndEnergySmart // = 5

    public init() {
      self = .reminderTypeEnergyManual
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .reminderTypeEnergyManual
      case 2: self = .reminderTypeEnergySmart
      case 3: self = .reminderTypeHydration
      case 4: self = .reminderTypeHydrationAndEnergyManual
      case 5: self = .reminderTypeHydrationAndEnergySmart
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .reminderTypeEnergyManual: return 1
      case .reminderTypeEnergySmart: return 2
      case .reminderTypeHydration: return 3
      case .reminderTypeHydrationAndEnergyManual: return 4
      case .reminderTypeHydrationAndEnergySmart: return 5
      }
    }

  }

  public init() {}

  fileprivate var _timestamp: PbDuration? = nil
  fileprivate var _fuelingReminderType: PbFuelingReminder.PbFuelingReminderType? = nil
}

#if swift(>=4.2)

extension PbFuelingReminder.PbFuelingReminderType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct PbTrainingLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Training load value of the exercise
  public var trainingLoadVal: UInt32 {
    get {return _trainingLoadVal ?? 0}
    set {_trainingLoadVal = newValue}
  }
  /// Returns true if `trainingLoadVal` has been explicitly set.
  public var hasTrainingLoadVal: Bool {return self._trainingLoadVal != nil}
  /// Clears the value of `trainingLoadVal`. Subsequent reads from it will return its default value.
  public mutating func clearTrainingLoadVal() {self._trainingLoadVal = nil}

  /// Recovery time in hours what the exercise caused
  public var recoveryTime: PbDuration {
    get {return _recoveryTime ?? PbDuration()}
    set {_recoveryTime = newValue}
  }
  /// Returns true if `recoveryTime` has been explicitly set.
  public var hasRecoveryTime: Bool {return self._recoveryTime != nil}
  /// Clears the value of `recoveryTime`. Subsequent reads from it will return its default value.
  public mutating func clearRecoveryTime() {self._recoveryTime = nil}

  /// Carbohydrates consumed during the exercise in percent's
  public var carbohydrateConsumption: UInt32 {
    get {return _carbohydrateConsumption ?? 0}
    set {_carbohydrateConsumption = newValue}
  }
  /// Returns true if `carbohydrateConsumption` has been explicitly set.
  public var hasCarbohydrateConsumption: Bool {return self._carbohydrateConsumption != nil}
  /// Clears the value of `carbohydrateConsumption`. Subsequent reads from it will return its default value.
  public mutating func clearCarbohydrateConsumption() {self._carbohydrateConsumption = nil}

  /// Proteins consumed during the exercise in percent's
  public var proteinConsumption: UInt32 {
    get {return _proteinConsumption ?? 0}
    set {_proteinConsumption = newValue}
  }
  /// Returns true if `proteinConsumption` has been explicitly set.
  public var hasProteinConsumption: Bool {return self._proteinConsumption != nil}
  /// Clears the value of `proteinConsumption`. Subsequent reads from it will return its default value.
  public mutating func clearProteinConsumption() {self._proteinConsumption = nil}

  /// Fats consumed during the exercise in percent's
  public var fatConsumption: UInt32 {
    get {return _fatConsumption ?? 0}
    set {_fatConsumption = newValue}
  }
  /// Returns true if `fatConsumption` has been explicitly set.
  public var hasFatConsumption: Bool {return self._fatConsumption != nil}
  /// Clears the value of `fatConsumption`. Subsequent reads from it will return its default value.
  public mutating func clearFatConsumption() {self._fatConsumption = nil}

  /// Carbohydrate consumption in grams
  public var carbohydrateGrams: Float {
    get {return _carbohydrateGrams ?? 0}
    set {_carbohydrateGrams = newValue}
  }
  /// Returns true if `carbohydrateGrams` has been explicitly set.
  public var hasCarbohydrateGrams: Bool {return self._carbohydrateGrams != nil}
  /// Clears the value of `carbohydrateGrams`. Subsequent reads from it will return its default value.
  public mutating func clearCarbohydrateGrams() {self._carbohydrateGrams = nil}

  /// Protein consumption in grams
  public var proteinGrams: Float {
    get {return _proteinGrams ?? 0}
    set {_proteinGrams = newValue}
  }
  /// Returns true if `proteinGrams` has been explicitly set.
  public var hasProteinGrams: Bool {return self._proteinGrams != nil}
  /// Clears the value of `proteinGrams`. Subsequent reads from it will return its default value.
  public mutating func clearProteinGrams() {self._proteinGrams = nil}

  /// Fat consumption in grams
  public var fatGrams: Float {
    get {return _fatGrams ?? 0}
    set {_fatGrams = newValue}
  }
  /// Returns true if `fatGrams` has been explicitly set.
  public var hasFatGrams: Bool {return self._fatGrams != nil}
  /// Clears the value of `fatGrams`. Subsequent reads from it will return its default value.
  public mutating func clearFatGrams() {self._fatGrams = nil}

  /// Size of the meal set for the exercise. Default 20 grams
  public var mealSize: Float {
    get {return _mealSize ?? 0}
    set {_mealSize = newValue}
  }
  /// Returns true if `mealSize` has been explicitly set.
  public var hasMealSize: Bool {return self._mealSize != nil}
  /// Clears the value of `mealSize`. Subsequent reads from it will return its default value.
  public mutating func clearMealSize() {self._mealSize = nil}

  /// Given fueling reminders during training session
  public var fuelingReminders: [PbFuelingReminder] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trainingLoadVal: UInt32? = nil
  fileprivate var _recoveryTime: PbDuration? = nil
  fileprivate var _carbohydrateConsumption: UInt32? = nil
  fileprivate var _proteinConsumption: UInt32? = nil
  fileprivate var _fatConsumption: UInt32? = nil
  fileprivate var _carbohydrateGrams: Float? = nil
  fileprivate var _proteinGrams: Float? = nil
  fileprivate var _fatGrams: Float? = nil
  fileprivate var _mealSize: Float? = nil
}

public struct PbHeartRateZone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Heart rate zone lower limit, range [0 -250] 1/min	
  public var lowerLimit: UInt32 {
    get {return _lowerLimit ?? 0}
    set {_lowerLimit = newValue}
  }
  /// Returns true if `lowerLimit` has been explicitly set.
  public var hasLowerLimit: Bool {return self._lowerLimit != nil}
  /// Clears the value of `lowerLimit`. Subsequent reads from it will return its default value.
  public mutating func clearLowerLimit() {self._lowerLimit = nil}

  ///Heart rate zone upper limit, range [0 -250] 1/min	
  public var higherLimit: UInt32 {
    get {return _higherLimit ?? 0}
    set {_higherLimit = newValue}
  }
  /// Returns true if `higherLimit` has been explicitly set.
  public var hasHigherLimit: Bool {return self._higherLimit != nil}
  /// Clears the value of `higherLimit`. Subsequent reads from it will return its default value.
  public mutating func clearHigherLimit() {self._higherLimit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lowerLimit: UInt32? = nil
  fileprivate var _higherLimit: UInt32? = nil
}

public struct PbSpeedZone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Speed zone lower limit, range [0.0 - 399.0] km/h
  public var lowerLimit: Float {
    get {return _lowerLimit ?? 0}
    set {_lowerLimit = newValue}
  }
  /// Returns true if `lowerLimit` has been explicitly set.
  public var hasLowerLimit: Bool {return self._lowerLimit != nil}
  /// Clears the value of `lowerLimit`. Subsequent reads from it will return its default value.
  public mutating func clearLowerLimit() {self._lowerLimit = nil}

  ///Speed zone upper limit, range [0.0 - 399.0] km/h
  public var higherLimit: Float {
    get {return _higherLimit ?? 0}
    set {_higherLimit = newValue}
  }
  /// Returns true if `higherLimit` has been explicitly set.
  public var hasHigherLimit: Bool {return self._higherLimit != nil}
  /// Clears the value of `higherLimit`. Subsequent reads from it will return its default value.
  public mutating func clearHigherLimit() {self._higherLimit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lowerLimit: Float? = nil
  fileprivate var _higherLimit: Float? = nil
}

public struct PbPowerZone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Power zone lower limit, range [0 - 2000] W
  public var lowerLimit: UInt32 {
    get {return _lowerLimit ?? 0}
    set {_lowerLimit = newValue}
  }
  /// Returns true if `lowerLimit` has been explicitly set.
  public var hasLowerLimit: Bool {return self._lowerLimit != nil}
  /// Clears the value of `lowerLimit`. Subsequent reads from it will return its default value.
  public mutating func clearLowerLimit() {self._lowerLimit = nil}

  ///Power zone upper limit, range [0 - 2000] W
  public var higherLimit: UInt32 {
    get {return _higherLimit ?? 0}
    set {_higherLimit = newValue}
  }
  /// Returns true if `higherLimit` has been explicitly set.
  public var hasHigherLimit: Bool {return self._higherLimit != nil}
  /// Clears the value of `higherLimit`. Subsequent reads from it will return its default value.
  public mutating func clearHigherLimit() {self._higherLimit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lowerLimit: UInt32? = nil
  fileprivate var _higherLimit: UInt32? = nil
}

public struct PbZones {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH MCLAREN RANGER ACE ARCHER SNIPER AVALON ASTRA VECTRA AUSTIN MASERATI ALPINA VESPER WOLFI METRO
  public var heartRateZone: [PbHeartRateZone] = []

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH MCLAREN RANGER ACE ARCHER SNIPER AVALON AUSTIN MASERATI METRO
  public var speedZone: [PbSpeedZone] = []

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH MCLAREN ARCHER SNIPER METRO
  public var powerZone: [PbPowerZone] = []

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH MCLAREN RANGER ACE ARCHER SNIPER AVALON ASTRA VECTRA AUSTIN MASERATI ALPINA VESPER WOLFI METRO
  public var heartRateSettingSource: PbHeartRateZoneSettingSource {
    get {return _heartRateSettingSource ?? .heartRateZoneSettingSourceDefault}
    set {_heartRateSettingSource = newValue}
  }
  /// Returns true if `heartRateSettingSource` has been explicitly set.
  public var hasHeartRateSettingSource: Bool {return self._heartRateSettingSource != nil}
  /// Clears the value of `heartRateSettingSource`. Subsequent reads from it will return its default value.
  public mutating func clearHeartRateSettingSource() {self._heartRateSettingSource = nil}

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH MCLAREN ARCHER SNIPER METRO
  public var powerSettingSource: PbPowerZoneSettingSource {
    get {return _powerSettingSource ?? .powerZoneSettingSourceDefault}
    set {_powerSettingSource = newValue}
  }
  /// Returns true if `powerSettingSource` has been explicitly set.
  public var hasPowerSettingSource: Bool {return self._powerSettingSource != nil}
  /// Clears the value of `powerSettingSource`. Subsequent reads from it will return its default value.
  public mutating func clearPowerSettingSource() {self._powerSettingSource = nil}

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH ACE RANGER ARCHER SNIPER AUSTIN MASERATI METRO
  public var speedSettingSource: PbSpeedZoneSettingSource {
    get {return _speedSettingSource ?? .speedZoneSettingSourceDefault}
    set {_speedSettingSource = newValue}
  }
  /// Returns true if `speedSettingSource` has been explicitly set.
  public var hasSpeedSettingSource: Bool {return self._speedSettingSource != nil}
  /// Clears the value of `speedSettingSource`. Subsequent reads from it will return its default value.
  public mutating func clearSpeedSettingSource() {self._speedSettingSource = nil}

  /// CHIRON
  public var powerZoneCalculationMethod: PbPowerZoneCalculationMethod {
    get {return _powerZoneCalculationMethod ?? .powerZoneCalculationMethodUnknown}
    set {_powerZoneCalculationMethod = newValue}
  }
  /// Returns true if `powerZoneCalculationMethod` has been explicitly set.
  public var hasPowerZoneCalculationMethod: Bool {return self._powerZoneCalculationMethod != nil}
  /// Clears the value of `powerZoneCalculationMethod`. Subsequent reads from it will return its default value.
  public mutating func clearPowerZoneCalculationMethod() {self._powerZoneCalculationMethod = nil}

  /// CHIRON
  public var speedZoneCalculationMethod: PbSpeedZoneCalculationMethod {
    get {return _speedZoneCalculationMethod ?? .speedZoneCalculationMethodUnknown}
    set {_speedZoneCalculationMethod = newValue}
  }
  /// Returns true if `speedZoneCalculationMethod` has been explicitly set.
  public var hasSpeedZoneCalculationMethod: Bool {return self._speedZoneCalculationMethod != nil}
  /// Clears the value of `speedZoneCalculationMethod`. Subsequent reads from it will return its default value.
  public mutating func clearSpeedZoneCalculationMethod() {self._speedZoneCalculationMethod = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _heartRateSettingSource: PbHeartRateZoneSettingSource? = nil
  fileprivate var _powerSettingSource: PbPowerZoneSettingSource? = nil
  fileprivate var _speedSettingSource: PbSpeedZoneSettingSource? = nil
  fileprivate var _powerZoneCalculationMethod: PbPowerZoneCalculationMethod? = nil
  fileprivate var _speedZoneCalculationMethod: PbSpeedZoneCalculationMethod? = nil
}

public struct PbBleMac {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mac: Data {
    get {return _mac ?? Data()}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  public var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  public mutating func clearMac() {self._mac = nil}

  public var type: PbMacType {
    get {return _type ?? .macTypePublic}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mac: Data? = nil
  fileprivate var _type: PbMacType? = nil
}

public struct PbBleDeviceName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Advertising name or name from DIS
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
}

public struct PbDeviceId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Used only with Polar devices
  public var deviceID: String {
    get {return _deviceID ?? String()}
    set {_deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  public var hasDeviceID: Bool {return self._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceID() {self._deviceID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceID: String? = nil
}

public struct PbRunningIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Running Index
  /// range [25 - 100] ml/kg/min
  public var value: UInt32 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// Time duration from exercise start to moment when index is calculated
  public var calculationTime: PbDuration {
    get {return _calculationTime ?? PbDuration()}
    set {_calculationTime = newValue}
  }
  /// Returns true if `calculationTime` has been explicitly set.
  public var hasCalculationTime: Bool {return self._calculationTime != nil}
  /// Clears the value of `calculationTime`. Subsequent reads from it will return its default value.
  public mutating func clearCalculationTime() {self._calculationTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt32? = nil
  fileprivate var _calculationTime: PbDuration? = nil
}

public struct PbSportIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sport identifier
  /// range [1 - xxx]
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
}

public struct PbOneLineText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text/name/etc meant to be printed in one line
  /// Max size is 45 UTF-8 characters excluding line end / null!
  /// Also note the max size is 45 characters, not bytes!
  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String? = nil
}

public struct PbMultiLineText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text/name/etc meant to be printed on multiple lines
  /// Maximum size is 1024. (nanopb).max_size definition removed due to ESW memory limits
  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String? = nil
}

public struct PbLanguageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Locale handling is specified in SAGRFC91, see https://wiki.polar.grp/x/d5j-Cg
  ///
  /// Two-letter lower case language code.
  /// See http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
  public var language: String {
    get {return _language ?? String()}
    set {_language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  public var hasLanguage: Bool {return self._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  public mutating func clearLanguage() {self._language = nil}

  /// Two-letter upper case region code
  /// See https://en.wikipedia.org/wiki/ISO_3166-1
  public var region: String {
    get {return _region ?? String()}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {self._region = nil}

  /// Four letter camel case script code
  /// See http://www.unicode.org/iso15924/iso15924-codes.html
  public var script: String {
    get {return _script ?? String()}
    set {_script = newValue}
  }
  /// Returns true if `script` has been explicitly set.
  public var hasScript: Bool {return self._script != nil}
  /// Clears the value of `script`. Subsequent reads from it will return its default value.
  public mutating func clearScript() {self._script = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _language: String? = nil
  fileprivate var _region: String? = nil
  fileprivate var _script: String? = nil
}

public struct PbTrainingSessionTargetId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem training session target identifier
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// Last modified timestamp from the referenced training session target
  public var lastModified: PbSystemDateTime {
    get {return _lastModified ?? PbSystemDateTime()}
    set {_lastModified = newValue}
  }
  /// Returns true if `lastModified` has been explicitly set.
  public var hasLastModified: Bool {return self._lastModified != nil}
  /// Clears the value of `lastModified`. Subsequent reads from it will return its default value.
  public mutating func clearLastModified() {self._lastModified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
  fileprivate var _lastModified: PbSystemDateTime? = nil
}

public struct PbTrainingSessionFavoriteId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem training session favorite identifier
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// Last modified timestamp from the referenced favorite training session target
  public var lastModified: PbSystemDateTime {
    get {return _lastModified ?? PbSystemDateTime()}
    set {_lastModified = newValue}
  }
  /// Returns true if `lastModified` has been explicitly set.
  public var hasLastModified: Bool {return self._lastModified != nil}
  /// Clears the value of `lastModified`. Subsequent reads from it will return its default value.
  public mutating func clearLastModified() {self._lastModified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
  fileprivate var _lastModified: PbSystemDateTime? = nil
}

public struct PbRouteId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem route identifier
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
}

public struct PbSwimmingPoolInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Swimming pool length in meters
  public var poolLength: Float {
    get {return _poolLength ?? 0}
    set {_poolLength = newValue}
  }
  /// Returns true if `poolLength` has been explicitly set.
  public var hasPoolLength: Bool {return self._poolLength != nil}
  /// Clears the value of `poolLength`. Subsequent reads from it will return its default value.
  public mutating func clearPoolLength() {self._poolLength = nil}

  /// Swimming pool type used
  public var swimmingPoolType: PbSwimmingPoolUnits {
    get {return _swimmingPoolType ?? .swimmingPoolMeters}
    set {_swimmingPoolType = newValue}
  }
  /// Returns true if `swimmingPoolType` has been explicitly set.
  public var hasSwimmingPoolType: Bool {return self._swimmingPoolType != nil}
  /// Clears the value of `swimmingPoolType`. Subsequent reads from it will return its default value.
  public mutating func clearSwimmingPoolType() {self._swimmingPoolType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _poolLength: Float? = nil
  fileprivate var _swimmingPoolType: PbSwimmingPoolUnits? = nil
}

public struct PbTrainingProgramId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem training program identifier
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
}

public struct PbEventId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem event identifier
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
}

public struct PbOnDemandTrainingTargetTypeId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem on demand training target type identifier
  /// List of the IDs: https://wiki.polar.grp/display/SYSFEA/Workout+Library
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
}

public struct PbPauseTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Offset from the beginning of the exercise
  /// Snapshot of exercise duration which does not include pause times
  ///   Exercise 12:00-12:10, two pauses: at 12:02-12:05 and 12:06-12:07.
  ///   Exercise duration is 6min
  ///   Pause times:
  ///   1. start _time 02:00 duration 03:00
  ///   2. start_time 03:00 duration 01:00
  public var startTime: PbDuration {
    get {return _startTime ?? PbDuration()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Duration of the pause period
  public var duration: PbDuration {
    get {return _duration ?? PbDuration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: PbDuration? = nil
  fileprivate var _duration: PbDuration? = nil
}

public struct PbApplicationId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ecosystem application identifier
  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: UInt64? = nil
}

public struct PbVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// range: 0-255
  public var major: UInt32 {
    get {return _major ?? 0}
    set {_major = newValue}
  }
  /// Returns true if `major` has been explicitly set.
  public var hasMajor: Bool {return self._major != nil}
  /// Clears the value of `major`. Subsequent reads from it will return its default value.
  public mutating func clearMajor() {self._major = nil}

  /// range: 0-255
  public var minor: UInt32 {
    get {return _minor ?? 0}
    set {_minor = newValue}
  }
  /// Returns true if `minor` has been explicitly set.
  public var hasMinor: Bool {return self._minor != nil}
  /// Clears the value of `minor`. Subsequent reads from it will return its default value.
  public mutating func clearMinor() {self._minor = nil}

  /// range: 0-65535
  public var patch: UInt32 {
    get {return _patch ?? 0}
    set {_patch = newValue}
  }
  /// Returns true if `patch` has been explicitly set.
  public var hasPatch: Bool {return self._patch != nil}
  /// Clears the value of `patch`. Subsequent reads from it will return its default value.
  public mutating func clearPatch() {self._patch = nil}

  /// ALL_TC
  public var specifier: String {
    get {return _specifier ?? String()}
    set {_specifier = newValue}
  }
  /// Returns true if `specifier` has been explicitly set.
  public var hasSpecifier: Bool {return self._specifier != nil}
  /// Clears the value of `specifier`. Subsequent reads from it will return its default value.
  public mutating func clearSpecifier() {self._specifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _major: UInt32? = nil
  fileprivate var _minor: UInt32? = nil
  fileprivate var _patch: UInt32? = nil
  fileprivate var _specifier: String? = nil
}

public struct PbAlgorithmVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OHR algorithm version
  public var ohrVersion: PbVersion {
    get {return _ohrVersion ?? PbVersion()}
    set {_ohrVersion = newValue}
  }
  /// Returns true if `ohrVersion` has been explicitly set.
  public var hasOhrVersion: Bool {return self._ohrVersion != nil}
  /// Clears the value of `ohrVersion`. Subsequent reads from it will return its default value.
  public mutating func clearOhrVersion() {self._ohrVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ohrVersion: PbVersion? = nil
}

public struct PbSubcomponentInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the component. For example "BleBootloader". Use unique names.
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The version that this main processor firmware requires for this sub component
  public var obsoleteRequiredVersion: PbVersion {
    get {return _obsoleteRequiredVersion ?? PbVersion()}
    set {_obsoleteRequiredVersion = newValue}
  }
  /// Returns true if `obsoleteRequiredVersion` has been explicitly set.
  public var hasObsoleteRequiredVersion: Bool {return self._obsoleteRequiredVersion != nil}
  /// Clears the value of `obsoleteRequiredVersion`. Subsequent reads from it will return its default value.
  public mutating func clearObsoleteRequiredVersion() {self._obsoleteRequiredVersion = nil}

  /// The version this sub component has now. 0.0.0 means error.
  public var version: PbVersion {
    get {return _version ?? PbVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _obsoleteRequiredVersion: PbVersion? = nil
  fileprivate var _version: PbVersion? = nil
}

public struct PbBleUuid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: Data? = nil
}

public struct PbBleCharacteristic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Should be uint16 but there is no such type?
  public var handle: UInt32 {
    get {return _handle ?? 0}
    set {_handle = newValue}
  }
  /// Returns true if `handle` has been explicitly set.
  public var hasHandle: Bool {return self._handle != nil}
  /// Clears the value of `handle`. Subsequent reads from it will return its default value.
  public mutating func clearHandle() {self._handle = nil}

  public var type: PbBleUuid {
    get {return _type ?? PbBleUuid()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _handle: UInt32? = nil
  fileprivate var _type: PbBleUuid? = nil
}

public struct PbBleService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serviceUuid: PbBleUuid {
    get {return _serviceUuid ?? PbBleUuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  public var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  public mutating func clearServiceUuid() {self._serviceUuid = nil}

  /// ALL_TC
  public var characteristics: [PbBleCharacteristic] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serviceUuid: PbBleUuid? = nil
}

/// 
///Metadata for identifying the source of a data
///
///Each field must be set in the case the value is available.
///
///If no suitable data is available for the only required field (i.e. no way to name the device), 
///then there's obviously no need to create this source message.
public struct PbSourceDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the device or app which has produced the data
  ///
  /// Polar device: Device name (e.g. "Polar V800 12345678", "Polar H10 87654321")
  /// Mobile app: Application name (e.g. "Polar Flow Android", "Polar Beat iOS")
  /// 3rd party device: Device name (first value that is available):
  /// 1) Device name from GAP (e.g "Stryd")
  /// 2) Manufacturer + model_number (e.g. "Stryd 2")
  /// 3) Just manufacturer (e.g. "Stryd")
  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  /// Device or app manufacturer
  /// 
  /// Polar device and mobile app: "Polar Electro Oy"
  /// 3rd party device: Manufacturer from DIS if available (e.g. "Stryd")
  public var manufacturer: String {
    get {return _storage._manufacturer ?? String()}
    set {_uniqueStorage()._manufacturer = newValue}
  }
  /// Returns true if `manufacturer` has been explicitly set.
  public var hasManufacturer: Bool {return _storage._manufacturer != nil}
  /// Clears the value of `manufacturer`. Subsequent reads from it will return its default value.
  public mutating func clearManufacturer() {_uniqueStorage()._manufacturer = nil}

  /// Device model number
  ///
  /// Polar device: "V800", "H10", ...
  /// Mobile app: "SM-G925F", "MQ7E2", ...
  /// 3rd party device: Model number from DIS if available (e.g. "2")
  public var modelNumber: String {
    get {return _storage._modelNumber ?? String()}
    set {_uniqueStorage()._modelNumber = newValue}
  }
  /// Returns true if `modelNumber` has been explicitly set.
  public var hasModelNumber: Bool {return _storage._modelNumber != nil}
  /// Clears the value of `modelNumber`. Subsequent reads from it will return its default value.
  public mutating func clearModelNumber() {_uniqueStorage()._modelNumber = nil}

  /// Device hardware code
  ///
  /// Polar device: hardware_code in device.proto (e.g. 00853923.01)
  /// Mobile app: Always absent
  /// 3rd party device: Hardware revision from DIS if available
  public var hardwareCode: String {
    get {return _storage._hardwareCode ?? String()}
    set {_uniqueStorage()._hardwareCode = newValue}
  }
  /// Returns true if `hardwareCode` has been explicitly set.
  public var hasHardwareCode: Bool {return _storage._hardwareCode != nil}
  /// Clears the value of `hardwareCode`. Subsequent reads from it will return its default value.
  public mutating func clearHardwareCode() {_uniqueStorage()._hardwareCode = nil}

  /// Device platform version
  ///
  /// Polar device: platform_version in device.proto
  /// Mobile app: OS version
  /// 3rd party device: Firmware revision from DIS if available
  public var platformVersion: PbVersion {
    get {return _storage._platformVersion ?? PbVersion()}
    set {_uniqueStorage()._platformVersion = newValue}
  }
  /// Returns true if `platformVersion` has been explicitly set.
  public var hasPlatformVersion: Bool {return _storage._platformVersion != nil}
  /// Clears the value of `platformVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformVersion() {_uniqueStorage()._platformVersion = nil}

  /// Device firmware version
  ///
  /// Polar device: device_version in device.proto
  /// Mobile app: Application version
  /// 3rd party device: Software version from DIS if available
  public var softwareVersion: PbVersion {
    get {return _storage._softwareVersion ?? PbVersion()}
    set {_uniqueStorage()._softwareVersion = newValue}
  }
  /// Returns true if `softwareVersion` has been explicitly set.
  public var hasSoftwareVersion: Bool {return _storage._softwareVersion != nil}
  /// Clears the value of `softwareVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSoftwareVersion() {_uniqueStorage()._softwareVersion = nil}

  /// Polar Math Smart version
  ///
  /// Polar devices: polarmathsmart_version in device.proto
  /// Mobile app: Polar Math Smart version
  /// 3rd party device: Always absent
  public var polarmathsmartVersion: PbVersion {
    get {return _storage._polarmathsmartVersion ?? PbVersion()}
    set {_uniqueStorage()._polarmathsmartVersion = newValue}
  }
  /// Returns true if `polarmathsmartVersion` has been explicitly set.
  public var hasPolarmathsmartVersion: Bool {return _storage._polarmathsmartVersion != nil}
  /// Clears the value of `polarmathsmartVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPolarmathsmartVersion() {_uniqueStorage()._polarmathsmartVersion = nil}

  /// Data collector
  ///
  /// This field is set only if the source device is an exernal sensor.
  /// Collector is the device (or app) that connects to the sensor and
  /// creates the data this PbSourceDevice is for.
  /// 
  /// E.g. If the source of HR data is OH1, then the collector here 
  /// could be e.g. Polar Beat
  public var collector: PbSourceDevice {
    get {return _storage._collector ?? PbSourceDevice()}
    set {_uniqueStorage()._collector = newValue}
  }
  /// Returns true if `collector` has been explicitly set.
  public var hasCollector: Bool {return _storage._collector != nil}
  /// Clears the value of `collector`. Subsequent reads from it will return its default value.
  public mutating func clearCollector() {_uniqueStorage()._collector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PbSampleSourceDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// On a sample array merged from multiple sources, this is the start index for 
  /// samples that have been produced by the device described by source_device. 
  /// The subsequence of samples produced by the source implicitly ends where the 
  /// next starts (or at the end of the sample array).
  public var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  public var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStartIndex() {self._startIndex = nil}

  /// Source device
  public var sourceDevice: PbSourceDevice {
    get {return _sourceDevice ?? PbSourceDevice()}
    set {_sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  public var hasSourceDevice: Bool {return self._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  public mutating func clearSourceDevice() {self._sourceDevice = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startIndex: UInt32? = nil
  fileprivate var _sourceDevice: PbSourceDevice? = nil
}

/// Defines the resistance used for a set of strength training movements
public struct PbStrengthTrainingResistance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of resistance
  public var resistanceType: PbStrengthTrainingResistance.PbStrengthTrainingResistanceType {
    get {return _resistanceType ?? .bodyWeight}
    set {_resistanceType = newValue}
  }
  /// Returns true if `resistanceType` has been explicitly set.
  public var hasResistanceType: Bool {return self._resistanceType != nil}
  /// Clears the value of `resistanceType`. Subsequent reads from it will return its default value.
  public mutating func clearResistanceType() {self._resistanceType = nil}

  /// Target weight to be used for the set if type == WEIGHT.
  public var weight: Float {
    get {return _weight ?? 0}
    set {_weight = newValue}
  }
  /// Returns true if `weight` has been explicitly set.
  public var hasWeight: Bool {return self._weight != nil}
  /// Clears the value of `weight`. Subsequent reads from it will return its default value.
  public mutating func clearWeight() {self._weight = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PbStrengthTrainingResistanceType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Body weight resistance, no additional weights
    case bodyWeight // = 0

    /// Additional weights
    case weight // = 1

    public init() {
      self = .bodyWeight
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bodyWeight
      case 1: self = .weight
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .bodyWeight: return 0
      case .weight: return 1
      }
    }

  }

  public init() {}

  fileprivate var _resistanceType: PbStrengthTrainingResistance.PbStrengthTrainingResistanceType? = nil
  fileprivate var _weight: Float? = nil
}

#if swift(>=4.2)

extension PbStrengthTrainingResistance.PbStrengthTrainingResistanceType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PbVolumeTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbVolumeTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_type"),
    2: .same(proto: "duration"),
    3: .same(proto: "distance"),
    4: .same(proto: "calories"),
  ]

  public var isInitialized: Bool {
    if self._targetType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._targetType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._distance) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._calories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._calories {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbVolumeTarget, rhs: PbVolumeTarget) -> Bool {
    if lhs._targetType != rhs._targetType {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._calories != rhs._calories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbVolumeTarget.PbVolymeTargetType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOLUME_TARGET_TYPE_DURATION"),
    1: .same(proto: "VOLUME_TARGET_TYPE_DISTANCE"),
    2: .same(proto: "VOLUME_TARGET_TYPE_CALORIES"),
  ]
}

extension PbStravaSegmentTargets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbStravaSegmentTargets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "own_best"),
    2: .standard(proto: "kom_qom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownBest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._komQom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownBest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._komQom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbStravaSegmentTargets, rhs: PbStravaSegmentTargets) -> Bool {
    if lhs._ownBest != rhs._ownBest {return false}
    if lhs._komQom != rhs._komQom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbStravaSegmentTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbStravaSegmentTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "strava_segment_type"),
    2: .standard(proto: "strava_segment_targets"),
  ]

  public var isInitialized: Bool {
    if self._stravaSegmentType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._stravaSegmentType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stravaSegmentTargets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stravaSegmentType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stravaSegmentTargets {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbStravaSegmentTarget, rhs: PbStravaSegmentTarget) -> Bool {
    if lhs._stravaSegmentType != rhs._stravaSegmentType {return false}
    if lhs._stravaSegmentTargets != rhs._stravaSegmentTargets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbStravaSegmentTarget.PbStravaSegmentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "STRAVA_SEGMENT_TYPE_RIDE"),
    2: .same(proto: "STRAVA_SEGMENT_TYPE_RUN"),
  ]
}

extension PbFuelingReminder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbFuelingReminder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "fueling_reminder_type"),
  ]

  public var isInitialized: Bool {
    if self._timestamp == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._fuelingReminderType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fuelingReminderType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbFuelingReminder, rhs: PbFuelingReminder) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._fuelingReminderType != rhs._fuelingReminderType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbFuelingReminder.PbFuelingReminderType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "REMINDER_TYPE_ENERGY_MANUAL"),
    2: .same(proto: "REMINDER_TYPE_ENERGY_SMART"),
    3: .same(proto: "REMINDER_TYPE_HYDRATION"),
    4: .same(proto: "REMINDER_TYPE_HYDRATION_AND_ENERGY_MANUAL"),
    5: .same(proto: "REMINDER_TYPE_HYDRATION_AND_ENERGY_SMART"),
  ]
}

extension PbTrainingLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbTrainingLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "training_load_val"),
    2: .standard(proto: "recovery_time"),
    3: .standard(proto: "carbohydrate_consumption"),
    4: .standard(proto: "protein_consumption"),
    5: .standard(proto: "fat_consumption"),
    6: .standard(proto: "carbohydrate_grams"),
    7: .standard(proto: "protein_grams"),
    8: .standard(proto: "fat_grams"),
    9: .standard(proto: "meal_size"),
    10: .standard(proto: "fueling_reminders"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.fuelingReminders) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._trainingLoadVal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recoveryTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._carbohydrateConsumption) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._proteinConsumption) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._fatConsumption) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._carbohydrateGrams) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._proteinGrams) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._fatGrams) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._mealSize) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.fuelingReminders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trainingLoadVal {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recoveryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._carbohydrateConsumption {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._proteinConsumption {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fatConsumption {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._carbohydrateGrams {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._proteinGrams {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._fatGrams {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._mealSize {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    if !self.fuelingReminders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fuelingReminders, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbTrainingLoad, rhs: PbTrainingLoad) -> Bool {
    if lhs._trainingLoadVal != rhs._trainingLoadVal {return false}
    if lhs._recoveryTime != rhs._recoveryTime {return false}
    if lhs._carbohydrateConsumption != rhs._carbohydrateConsumption {return false}
    if lhs._proteinConsumption != rhs._proteinConsumption {return false}
    if lhs._fatConsumption != rhs._fatConsumption {return false}
    if lhs._carbohydrateGrams != rhs._carbohydrateGrams {return false}
    if lhs._proteinGrams != rhs._proteinGrams {return false}
    if lhs._fatGrams != rhs._fatGrams {return false}
    if lhs._mealSize != rhs._mealSize {return false}
    if lhs.fuelingReminders != rhs.fuelingReminders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbHeartRateZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbHeartRateZone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lower_limit"),
    2: .standard(proto: "higher_limit"),
  ]

  public var isInitialized: Bool {
    if self._lowerLimit == nil {return false}
    if self._higherLimit == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._lowerLimit) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._higherLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lowerLimit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._higherLimit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbHeartRateZone, rhs: PbHeartRateZone) -> Bool {
    if lhs._lowerLimit != rhs._lowerLimit {return false}
    if lhs._higherLimit != rhs._higherLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSpeedZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSpeedZone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lower_limit"),
    2: .standard(proto: "higher_limit"),
  ]

  public var isInitialized: Bool {
    if self._lowerLimit == nil {return false}
    if self._higherLimit == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._lowerLimit) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._higherLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lowerLimit {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._higherLimit {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSpeedZone, rhs: PbSpeedZone) -> Bool {
    if lhs._lowerLimit != rhs._lowerLimit {return false}
    if lhs._higherLimit != rhs._higherLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbPowerZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbPowerZone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lower_limit"),
    2: .standard(proto: "higher_limit"),
  ]

  public var isInitialized: Bool {
    if self._lowerLimit == nil {return false}
    if self._higherLimit == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._lowerLimit) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._higherLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lowerLimit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._higherLimit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbPowerZone, rhs: PbPowerZone) -> Bool {
    if lhs._lowerLimit != rhs._lowerLimit {return false}
    if lhs._higherLimit != rhs._higherLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbZones: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbZones"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "heart_rate_zone"),
    2: .standard(proto: "speed_zone"),
    3: .standard(proto: "power_zone"),
    10: .standard(proto: "heart_rate_setting_source"),
    11: .standard(proto: "power_setting_source"),
    12: .standard(proto: "speed_setting_source"),
    13: .standard(proto: "power_zone_calculation_method"),
    14: .standard(proto: "speed_zone_calculation_method"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.heartRateZone) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.speedZone) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.powerZone) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.heartRateZone) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.speedZone) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.powerZone) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self._heartRateSettingSource) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self._powerSettingSource) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self._speedSettingSource) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self._powerZoneCalculationMethod) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self._speedZoneCalculationMethod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.heartRateZone.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.heartRateZone, fieldNumber: 1)
    }
    if !self.speedZone.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.speedZone, fieldNumber: 2)
    }
    if !self.powerZone.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.powerZone, fieldNumber: 3)
    }
    try { if let v = self._heartRateSettingSource {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._powerSettingSource {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._speedSettingSource {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._powerZoneCalculationMethod {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._speedZoneCalculationMethod {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbZones, rhs: PbZones) -> Bool {
    if lhs.heartRateZone != rhs.heartRateZone {return false}
    if lhs.speedZone != rhs.speedZone {return false}
    if lhs.powerZone != rhs.powerZone {return false}
    if lhs._heartRateSettingSource != rhs._heartRateSettingSource {return false}
    if lhs._powerSettingSource != rhs._powerSettingSource {return false}
    if lhs._speedSettingSource != rhs._speedSettingSource {return false}
    if lhs._powerZoneCalculationMethod != rhs._powerZoneCalculationMethod {return false}
    if lhs._speedZoneCalculationMethod != rhs._speedZoneCalculationMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbBleMac: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbBleMac"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mac"),
    2: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._mac == nil {return false}
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mac) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbBleMac, rhs: PbBleMac) -> Bool {
    if lhs._mac != rhs._mac {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbBleDeviceName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbBleDeviceName"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbBleDeviceName, rhs: PbBleDeviceName) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbDeviceId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbDeviceId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  public var isInitialized: Bool {
    if self._deviceID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbDeviceId, rhs: PbDeviceId) -> Bool {
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbRunningIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbRunningIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "calculation_time"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._calculationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._calculationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbRunningIndex, rhs: PbRunningIndex) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._calculationTime != rhs._calculationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSportIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSportIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSportIdentifier, rhs: PbSportIdentifier) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbOneLineText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbOneLineText"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public var isInitialized: Bool {
    if self._text == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbOneLineText, rhs: PbOneLineText) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMultiLineText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbMultiLineText"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public var isInitialized: Bool {
    if self._text == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbMultiLineText, rhs: PbMultiLineText) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbLanguageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbLanguageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
    2: .same(proto: "region"),
    3: .same(proto: "script"),
  ]

  public var isInitialized: Bool {
    if self._language == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._language) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._script) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._script {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbLanguageId, rhs: PbLanguageId) -> Bool {
    if lhs._language != rhs._language {return false}
    if lhs._region != rhs._region {return false}
    if lhs._script != rhs._script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbTrainingSessionTargetId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbTrainingSessionTargetId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "last_modified"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    if let v = self._lastModified, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastModified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbTrainingSessionTargetId, rhs: PbTrainingSessionTargetId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._lastModified != rhs._lastModified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbTrainingSessionFavoriteId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbTrainingSessionFavoriteId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "last_modified"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    if let v = self._lastModified, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastModified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbTrainingSessionFavoriteId, rhs: PbTrainingSessionFavoriteId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._lastModified != rhs._lastModified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbRouteId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbRouteId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbRouteId, rhs: PbRouteId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSwimmingPoolInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSwimmingPoolInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_length"),
    2: .standard(proto: "swimming_pool_type"),
  ]

  public var isInitialized: Bool {
    if self._swimmingPoolType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._poolLength) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._swimmingPoolType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolLength {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._swimmingPoolType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSwimmingPoolInfo, rhs: PbSwimmingPoolInfo) -> Bool {
    if lhs._poolLength != rhs._poolLength {return false}
    if lhs._swimmingPoolType != rhs._swimmingPoolType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbTrainingProgramId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbTrainingProgramId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbTrainingProgramId, rhs: PbTrainingProgramId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbEventId, rhs: PbEventId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbOnDemandTrainingTargetTypeId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbOnDemandTrainingTargetTypeId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbOnDemandTrainingTargetTypeId, rhs: PbOnDemandTrainingTargetTypeId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbPauseTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbPauseTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .same(proto: "duration"),
  ]

  public var isInitialized: Bool {
    if self._startTime == nil {return false}
    if self._duration == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbPauseTime, rhs: PbPauseTime) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbApplicationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbApplicationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbApplicationId, rhs: PbApplicationId) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "major"),
    2: .same(proto: "minor"),
    3: .same(proto: "patch"),
    4: .same(proto: "specifier"),
  ]

  public var isInitialized: Bool {
    if self._major == nil {return false}
    if self._minor == nil {return false}
    if self._patch == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._major) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._minor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._patch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._specifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._major {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._patch {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._specifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbVersion, rhs: PbVersion) -> Bool {
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs._patch != rhs._patch {return false}
    if lhs._specifier != rhs._specifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbAlgorithmVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbAlgorithmVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ohr_version"),
  ]

  public var isInitialized: Bool {
    if let v = self._ohrVersion, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ohrVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ohrVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbAlgorithmVersion, rhs: PbAlgorithmVersion) -> Bool {
    if lhs._ohrVersion != rhs._ohrVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSubcomponentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSubcomponentInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "OBSOLETE_required_version"),
    3: .same(proto: "version"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if let v = self._obsoleteRequiredVersion, !v.isInitialized {return false}
    if let v = self._version, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._obsoleteRequiredVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._obsoleteRequiredVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSubcomponentInfo, rhs: PbSubcomponentInfo) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._obsoleteRequiredVersion != rhs._obsoleteRequiredVersion {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbBleUuid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbBleUuid"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbBleUuid, rhs: PbBleUuid) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbBleCharacteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbBleCharacteristic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handle"),
    2: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._handle == nil {return false}
    if self._type == nil {return false}
    if let v = self._type, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._handle) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._handle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbBleCharacteristic, rhs: PbBleCharacteristic) -> Bool {
    if lhs._handle != rhs._handle {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbBleService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbBleService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "characteristics"),
  ]

  public var isInitialized: Bool {
    if self._serviceUuid == nil {return false}
    if let v = self._serviceUuid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.characteristics) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbBleService, rhs: PbBleService) -> Bool {
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSourceDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSourceDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "manufacturer"),
    3: .standard(proto: "model_number"),
    4: .standard(proto: "hardware_code"),
    5: .standard(proto: "platform_version"),
    6: .standard(proto: "software_version"),
    7: .standard(proto: "polarmathsmart_version"),
    8: .same(proto: "collector"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _manufacturer: String? = nil
    var _modelNumber: String? = nil
    var _hardwareCode: String? = nil
    var _platformVersion: PbVersion? = nil
    var _softwareVersion: PbVersion? = nil
    var _polarmathsmartVersion: PbVersion? = nil
    var _collector: PbSourceDevice? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _manufacturer = source._manufacturer
      _modelNumber = source._modelNumber
      _hardwareCode = source._hardwareCode
      _platformVersion = source._platformVersion
      _softwareVersion = source._softwareVersion
      _polarmathsmartVersion = source._polarmathsmartVersion
      _collector = source._collector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if let v = _storage._platformVersion, !v.isInitialized {return false}
      if let v = _storage._softwareVersion, !v.isInitialized {return false}
      if let v = _storage._polarmathsmartVersion, !v.isInitialized {return false}
      if let v = _storage._collector, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._manufacturer) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._modelNumber) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hardwareCode) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._platformVersion) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._softwareVersion) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._polarmathsmartVersion) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._collector) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._manufacturer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modelNumber {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._hardwareCode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._platformVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._softwareVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._polarmathsmartVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._collector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSourceDevice, rhs: PbSourceDevice) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._manufacturer != rhs_storage._manufacturer {return false}
        if _storage._modelNumber != rhs_storage._modelNumber {return false}
        if _storage._hardwareCode != rhs_storage._hardwareCode {return false}
        if _storage._platformVersion != rhs_storage._platformVersion {return false}
        if _storage._softwareVersion != rhs_storage._softwareVersion {return false}
        if _storage._polarmathsmartVersion != rhs_storage._polarmathsmartVersion {return false}
        if _storage._collector != rhs_storage._collector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSampleSourceDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSampleSourceDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_index"),
    2: .standard(proto: "source_device"),
  ]

  public var isInitialized: Bool {
    if self._startIndex == nil {return false}
    if self._sourceDevice == nil {return false}
    if let v = self._sourceDevice, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sourceDevice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sourceDevice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSampleSourceDevice, rhs: PbSampleSourceDevice) -> Bool {
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs._sourceDevice != rhs._sourceDevice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbStrengthTrainingResistance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbStrengthTrainingResistance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resistance_type"),
    2: .same(proto: "weight"),
  ]

  public var isInitialized: Bool {
    if self._resistanceType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._resistanceType) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._weight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resistanceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._weight {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbStrengthTrainingResistance, rhs: PbStrengthTrainingResistance) -> Bool {
    if lhs._resistanceType != rhs._resistanceType {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbStrengthTrainingResistance.PbStrengthTrainingResistanceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BODY_WEIGHT"),
    1: .same(proto: "WEIGHT"),
  ]
}
