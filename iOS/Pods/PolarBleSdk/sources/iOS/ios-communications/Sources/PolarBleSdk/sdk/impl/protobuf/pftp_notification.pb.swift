// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pftp_notification.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Types for device to host notifications (SAGRFC53).
/// Device to host notification parameters, if any, are transmitted in the following
/// data (SAGRFC56) and defined below, individually per notification type.
public enum Protocol_PbPFtpDevToHostNotification: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// (Not used currently for anything. Reserved for future use.)
  case filesystemModified // = 0

  /// Used to inform host about internal test data.
  case internalTestEvent // = 1

  /// Used to inform host when the device is ready to communicate again after reporting WAIT_FOR_IDLING error.
  case idling // = 2

  /// Used to inform host about device's battery status.
  case batteryStatus // = 3

  /// Used to inform host about user's inactivity.
  case inactivityAlert // = 4

  /// Used to inform host about training session status.
  case trainingSessionStatus // = 5

  /// Used by device to request host to sync. This happens for example when user presses "Sync" button in the device.
  case syncRequired // = 7

  /// Used by device to inform result of START_AUTOSYNC synchronization.
  case autosyncStatus // = 8

  /// Used to send responses to Polar Notification Service notifications.
  case pnsDhNotificationResponse // = 9

  /// Used for Polar Notification Service settings
  case pnsSettings // = 10

  /// Used to request mobile device to start GPS measurement. Parameter PbPftpStartGPSMeasurement
  case startGpsMeasurement // = 11

  /// Used to request mobile device to stop GPS measurement. No parameters
  case stopGpsMeasurement // = 12

  /// Used to keep mobile running in background. No parameters
  case keepBackgroundAlive // = 13

  /// Polar shell is to transfer any test related data from device to host
  case polarShellDhData // = 14

  public init() {
    self = .filesystemModified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .filesystemModified
    case 1: self = .internalTestEvent
    case 2: self = .idling
    case 3: self = .batteryStatus
    case 4: self = .inactivityAlert
    case 5: self = .trainingSessionStatus
    case 7: self = .syncRequired
    case 8: self = .autosyncStatus
    case 9: self = .pnsDhNotificationResponse
    case 10: self = .pnsSettings
    case 11: self = .startGpsMeasurement
    case 12: self = .stopGpsMeasurement
    case 13: self = .keepBackgroundAlive
    case 14: self = .polarShellDhData
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .filesystemModified: return 0
    case .internalTestEvent: return 1
    case .idling: return 2
    case .batteryStatus: return 3
    case .inactivityAlert: return 4
    case .trainingSessionStatus: return 5
    case .syncRequired: return 7
    case .autosyncStatus: return 8
    case .pnsDhNotificationResponse: return 9
    case .pnsSettings: return 10
    case .startGpsMeasurement: return 11
    case .stopGpsMeasurement: return 12
    case .keepBackgroundAlive: return 13
    case .polarShellDhData: return 14
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPFtpDevToHostNotification: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum Protocol_Action: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case created // = 0
  case updated // = 1
  case removed // = 2

  public init() {
    self = .created
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .created
    case 1: self = .updated
    case 2: self = .removed
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .created: return 0
    case .updated: return 1
    case .removed: return 2
    }
  }

}

#if swift(>=4.2)

extension Protocol_Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum Protocol_PbPftpPnsDHAttributeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownAction // = 1
  case positiveAction // = 2
  case negativeAction // = 3
  case clearAction // = 4
  case aAction // = 5
  case bAction // = 6
  case cAction // = 7
  case dAction // = 8

  public init() {
    self = .unknownAction
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .unknownAction
    case 2: self = .positiveAction
    case 3: self = .negativeAction
    case 4: self = .clearAction
    case 5: self = .aAction
    case 6: self = .bAction
    case 7: self = .cAction
    case 8: self = .dAction
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownAction: return 1
    case .positiveAction: return 2
    case .negativeAction: return 3
    case .clearAction: return 4
    case .aAction: return 5
    case .bAction: return 6
    case .cAction: return 7
    case .dAction: return 8
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPftpPnsDHAttributeType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Types for host to device notifications (SAGRFC53).
/// Host to device notification parameters, if any, are transmitted in the following
/// data (SAGRFC56) and defined below, individually per notification type.
public enum Protocol_PbPFtpHostToDevNotification: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Instructs device to show syncing animation
  case startSync // = 0

  /// Instructs device to hide syncing animation
  case stopSync // = 1
  case reset // = 2
  case lockProductionData // = 3

  ///Sync terminate notification overrides start and stop sync sequency. 
  ///Device is forced to ignore and terminate running synchonization.
  case terminateSync // = 4

  /// keep alive, mainly for wireless connection to maintain link.
  case keepAlive // = 5

  /// Command the device to perform autosync if the device is able to automatically sync to a web service for instance.
  case startAutosync // = 6
  case pnsHdNotification // = 7

  /// Instructs the device to initialize connection, if necessary.
  case initializeSession // = 8

  /// Instructs the device to terminate connection, if possible.
  case terminateSession // = 9

  /// Instruct the device to simulate button press
  case simulateButtonPress // = 10

  /// Instruct the device to simulate touch screen
  case simulateTouchScreen // = 11

  /// Instructs the device to start sync session, if possible
  case requestSync // = 12

  /// Notify the device that a new firmware is available
  case firmwareUpdateAvailable // = 13

  /// GPS data for device when using mobile as GPS sensor
  case gpsData // = 14

  /// Indication of lost GPS signal for device when using mobile as GPS sensor
  case gpsLost // = 15

  /// User has not given permission to use mobile's GPS sensor
  case gpsNoPermission // = 16

  /// Polar shell is to transfer any test related data from host to device
  case polarShellHdData // = 17

  public init() {
    self = .startSync
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startSync
    case 1: self = .stopSync
    case 2: self = .reset
    case 3: self = .lockProductionData
    case 4: self = .terminateSync
    case 5: self = .keepAlive
    case 6: self = .startAutosync
    case 7: self = .pnsHdNotification
    case 8: self = .initializeSession
    case 9: self = .terminateSession
    case 10: self = .simulateButtonPress
    case 11: self = .simulateTouchScreen
    case 12: self = .requestSync
    case 13: self = .firmwareUpdateAvailable
    case 14: self = .gpsData
    case 15: self = .gpsLost
    case 16: self = .gpsNoPermission
    case 17: self = .polarShellHdData
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .startSync: return 0
    case .stopSync: return 1
    case .reset: return 2
    case .lockProductionData: return 3
    case .terminateSync: return 4
    case .keepAlive: return 5
    case .startAutosync: return 6
    case .pnsHdNotification: return 7
    case .initializeSession: return 8
    case .terminateSession: return 9
    case .simulateButtonPress: return 10
    case .simulateTouchScreen: return 11
    case .requestSync: return 12
    case .firmwareUpdateAvailable: return 13
    case .gpsData: return 14
    case .gpsLost: return 15
    case .gpsNoPermission: return 16
    case .polarShellHdData: return 17
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPFtpHostToDevNotification: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum Protocol_PbPftpPnsHDCategoryID: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case categoryIDOther // = 0
  case categoryIDPolar // = 1
  case categoryIDIncomingcall // = 2
  case categoryIDMissedcall // = 3
  case categoryIDVoicemail // = 4
  case categoryIDSocial // = 5
  case categoryIDSchedule // = 6
  case categoryIDEmail // = 7
  case categoryIDNews // = 8
  case categoryIDHealthandfitness // = 9
  case categoryIDBusinessandfinance // = 10
  case categoryIDLocation // = 11
  case categoryIDEntertainment // = 12

  ///Alarm or timer.
  case categoryIDAlarm // = 13

  ///Promotion or advertisement. 
  case categoryIDPromo // = 14

  ///A specific, timely recommendation for a single thing. 
  case categoryIDRecommendation // = 15

  ///Ongoing information about device or contextual status. 
  case categoryIDStatus // = 16

  ///Media transport control for playback.
  case categoryIDTransport // = 17

  public init() {
    self = .categoryIDOther
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .categoryIDOther
    case 1: self = .categoryIDPolar
    case 2: self = .categoryIDIncomingcall
    case 3: self = .categoryIDMissedcall
    case 4: self = .categoryIDVoicemail
    case 5: self = .categoryIDSocial
    case 6: self = .categoryIDSchedule
    case 7: self = .categoryIDEmail
    case 8: self = .categoryIDNews
    case 9: self = .categoryIDHealthandfitness
    case 10: self = .categoryIDBusinessandfinance
    case 11: self = .categoryIDLocation
    case 12: self = .categoryIDEntertainment
    case 13: self = .categoryIDAlarm
    case 14: self = .categoryIDPromo
    case 15: self = .categoryIDRecommendation
    case 16: self = .categoryIDStatus
    case 17: self = .categoryIDTransport
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .categoryIDOther: return 0
    case .categoryIDPolar: return 1
    case .categoryIDIncomingcall: return 2
    case .categoryIDMissedcall: return 3
    case .categoryIDVoicemail: return 4
    case .categoryIDSocial: return 5
    case .categoryIDSchedule: return 6
    case .categoryIDEmail: return 7
    case .categoryIDNews: return 8
    case .categoryIDHealthandfitness: return 9
    case .categoryIDBusinessandfinance: return 10
    case .categoryIDLocation: return 11
    case .categoryIDEntertainment: return 12
    case .categoryIDAlarm: return 13
    case .categoryIDPromo: return 14
    case .categoryIDRecommendation: return 15
    case .categoryIDStatus: return 16
    case .categoryIDTransport: return 17
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPftpPnsHDCategoryID: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Host to device attribute type 
public enum Protocol_PbPftpPnsHDAttributeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case title // = 0
  case subtitle // = 1
  case message // = 2
  case positiveActionLabel // = 3
  case negativeActionLabel // = 4
  case applicationName // = 5
  case clearActionLabel // = 6
  case aActionLabel // = 7
  case bActionLabel // = 8
  case cActionLabel // = 9
  case dActionLabel // = 10

  public init() {
    self = .title
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .title
    case 1: self = .subtitle
    case 2: self = .message
    case 3: self = .positiveActionLabel
    case 4: self = .negativeActionLabel
    case 5: self = .applicationName
    case 6: self = .clearActionLabel
    case 7: self = .aActionLabel
    case 8: self = .bActionLabel
    case 9: self = .cActionLabel
    case 10: self = .dActionLabel
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .title: return 0
    case .subtitle: return 1
    case .message: return 2
    case .positiveActionLabel: return 3
    case .negativeActionLabel: return 4
    case .applicationName: return 5
    case .clearActionLabel: return 6
    case .aActionLabel: return 7
    case .bActionLabel: return 8
    case .cActionLabel: return 9
    case .dActionLabel: return 10
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPftpPnsHDAttributeType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Protocol_PbPFtpFilesystemModifiedParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Taken action on a file or directory.
  public var action: Protocol_Action {
    get {return _action ?? .created}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  /// Path to the file or directory. Ending directory delimiter designates directory. Otherwise the path is considered to refer to a file.
  public var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: Protocol_Action? = nil
  fileprivate var _path: String? = nil
}

///
/// Parameters for INACTIVITY_ALERT device to host notification.
public struct Protocol_PbPFtpInactivityAlert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Countdown to inactivity alert in minutes. 0 means that the alert has been triggered. >0 means pre-alert notification.
  public var countdown: UInt32 {
    get {return _countdown ?? 0}
    set {_countdown = newValue}
  }
  /// Returns true if `countdown` has been explicitly set.
  public var hasCountdown: Bool {return self._countdown != nil}
  /// Clears the value of `countdown`. Subsequent reads from it will return its default value.
  public mutating func clearCountdown() {self._countdown = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _countdown: UInt32? = nil
}

///
/// Parameters for TRAINING_SESSION_STATUS device to host notification.
public struct Protocol_PbPFtpTrainingSessionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, training session is inprogress or was started. False, when training session ended.
  public var inprogress: Bool {
    get {return _inprogress ?? false}
    set {_inprogress = newValue}
  }
  /// Returns true if `inprogress` has been explicitly set.
  public var hasInprogress: Bool {return self._inprogress != nil}
  /// Clears the value of `inprogress`. Subsequent reads from it will return its default value.
  public mutating func clearInprogress() {self._inprogress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inprogress: Bool? = nil
}

///
/// Parameters for AUTOSYNC_STATUS device to host notification.
public struct Protocol_PbPFtpAutoSyncStatusParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, autosync completed successfully. False, if the synchronization failed.
  public var succeeded: Bool {
    get {return _succeeded ?? false}
    set {_succeeded = newValue}
  }
  /// Returns true if `succeeded` has been explicitly set.
  public var hasSucceeded: Bool {return self._succeeded != nil}
  /// Clears the value of `succeeded`. Subsequent reads from it will return its default value.
  public mutating func clearSucceeded() {self._succeeded = nil}

  ///description of the failed synchronization, TODO define these. One example is timeout.
  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _succeeded: Bool? = nil
  fileprivate var _description_p: String? = nil
}

///
/// Parameters for Polar shell device to host notification
public struct Protocol_PbPFtpPolarShellMessageParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// polar shell message id
  public var polarShellMsgID: UInt32 {
    get {return _polarShellMsgID ?? 0}
    set {_polarShellMsgID = newValue}
  }
  /// Returns true if `polarShellMsgID` has been explicitly set.
  public var hasPolarShellMsgID: Bool {return self._polarShellMsgID != nil}
  /// Clears the value of `polarShellMsgID`. Subsequent reads from it will return its default value.
  public mutating func clearPolarShellMsgID() {self._polarShellMsgID = nil}

  /// optional data for the notification
  public var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _polarShellMsgID: UInt32? = nil
  fileprivate var _data: String? = nil
}

public struct Protocol_PbPftpPnsDHAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_PbPftpPnsDHAttributeType {
    get {return _type ?? .unknownAction}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Protocol_PbPftpPnsDHAttributeType? = nil
}

public struct Protocol_PbPftpPnsDHNotificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationID: UInt32 {
    get {return _notificationID ?? 0}
    set {_notificationID = newValue}
  }
  /// Returns true if `notificationID` has been explicitly set.
  public var hasNotificationID: Bool {return self._notificationID != nil}
  /// Clears the value of `notificationID`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationID() {self._notificationID = nil}

  public var attributes: [Protocol_PbPftpPnsDHAttribute] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notificationID: UInt32? = nil
}

public struct Protocol_PbPftpPnsState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationsEnabled: Bool {
    get {return _notificationsEnabled ?? false}
    set {_notificationsEnabled = newValue}
  }
  /// Returns true if `notificationsEnabled` has been explicitly set.
  public var hasNotificationsEnabled: Bool {return self._notificationsEnabled != nil}
  /// Clears the value of `notificationsEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationsEnabled() {self._notificationsEnabled = nil}

  ///False if not available
  public var previewEnabled: Bool {
    get {return _previewEnabled ?? false}
    set {_previewEnabled = newValue}
  }
  /// Returns true if `previewEnabled` has been explicitly set.
  public var hasPreviewEnabled: Bool {return self._previewEnabled != nil}
  /// Clears the value of `previewEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearPreviewEnabled() {self._previewEnabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notificationsEnabled: Bool? = nil
  fileprivate var _previewEnabled: Bool? = nil
}

public struct Protocol_PbPftpStartGPSMeasurement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum GPS data notification sending interval in milliseconds
  public var minimumInterval: UInt32 {
    get {return _minimumInterval ?? 1000}
    set {_minimumInterval = newValue}
  }
  /// Returns true if `minimumInterval` has been explicitly set.
  public var hasMinimumInterval: Bool {return self._minimumInterval != nil}
  /// Clears the value of `minimumInterval`. Subsequent reads from it will return its default value.
  public mutating func clearMinimumInterval() {self._minimumInterval = nil}

  /// Needed distance increment in meters for sending GPS data notification
  public var accuracy: UInt32 {
    get {return _accuracy ?? 2}
    set {_accuracy = newValue}
  }
  /// Returns true if `accuracy` has been explicitly set.
  public var hasAccuracy: Bool {return self._accuracy != nil}
  /// Clears the value of `accuracy`. Subsequent reads from it will return its default value.
  public mutating func clearAccuracy() {self._accuracy = nil}

  ///latitude (in degrees) of location to start distance cumulation. Leave empty if start location is next availalbe gps location.
  ///value is positive on northern hemisphere
  public var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  public var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  public mutating func clearLatitude() {self._latitude = nil}

  ///Longitude (in degrees) of location to start distance cumulation. Leave empty if start location is next availalbe gps location.
  ///value is positive on northern hemisphere
  public var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  public var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  public mutating func clearLongitude() {self._longitude = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _minimumInterval: UInt32? = nil
  fileprivate var _accuracy: UInt32? = nil
  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
}

///
/// Parameters for INITIALIZE_SESSION host to device notification.
public struct Protocol_PbInitializeSessionParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// host may give information wheather it uses att level reponse packets from host to device
  public var usesAttributeLevelResponse: Bool {
    get {return _usesAttributeLevelResponse ?? false}
    set {_usesAttributeLevelResponse = newValue}
  }
  /// Returns true if `usesAttributeLevelResponse` has been explicitly set.
  public var hasUsesAttributeLevelResponse: Bool {return self._usesAttributeLevelResponse != nil}
  /// Clears the value of `usesAttributeLevelResponse`. Subsequent reads from it will return its default value.
  public mutating func clearUsesAttributeLevelResponse() {self._usesAttributeLevelResponse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usesAttributeLevelResponse: Bool? = nil
}

///
/// Parameters for FIRMWARE_UPDATE_AVAILABLE host to device notification.
public struct Protocol_PbFirmwareUpdateAvailableParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is update mandatory or not
  public var mandatory: Bool {
    get {return _mandatory ?? false}
    set {_mandatory = newValue}
  }
  /// Returns true if `mandatory` has been explicitly set.
  public var hasMandatory: Bool {return self._mandatory != nil}
  /// Clears the value of `mandatory`. Subsequent reads from it will return its default value.
  public mutating func clearMandatory() {self._mandatory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mandatory: Bool? = nil
}

///
/// Parameters for SIMULATE_BUTTON_PRESS host to device notification.
public struct Protocol_PbPFtpSimulateButtonPressParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines the button to change state
  public var button: Buttons {
    get {return _button ?? .buttonPlus}
    set {_button = newValue}
  }
  /// Returns true if `button` has been explicitly set.
  public var hasButton: Bool {return self._button != nil}
  /// Clears the value of `button`. Subsequent reads from it will return its default value.
  public mutating func clearButton() {self._button = nil}

  /// Defines the new state of button
  public var state: ButtonState {
    get {return _state ?? .buttonPressed}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _button: Buttons? = nil
  fileprivate var _state: ButtonState? = nil
}

public struct Protocol_PbPFtpTouchPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pixel coordinate if max_pos is not available, otherwise proportional position on display
  public var pos: UInt32 {
    get {return _pos ?? 0}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  public var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  public mutating func clearPos() {self._pos = nil}

  /// maximum position value
  public var maxPos: UInt32 {
    get {return _maxPos ?? 0}
    set {_maxPos = newValue}
  }
  /// Returns true if `maxPos` has been explicitly set.
  public var hasMaxPos: Bool {return self._maxPos != nil}
  /// Clears the value of `maxPos`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPos() {self._maxPos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pos: UInt32? = nil
  fileprivate var _maxPos: UInt32? = nil
}

///
/// Parameters for SIMULATE_TOUCH_SCREEN host to device notification.
public struct Protocol_PbPFtpSimulateTouchScreenParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState {
    get {return _state ?? .touchStateStart}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  /// horizontal touch position, available only if touch state is TOUCH_STATE_START or TOUCH_STATE_POSITION
  public var xPos: Protocol_PbPFtpTouchPosition {
    get {return _xPos ?? Protocol_PbPFtpTouchPosition()}
    set {_xPos = newValue}
  }
  /// Returns true if `xPos` has been explicitly set.
  public var hasXPos: Bool {return self._xPos != nil}
  /// Clears the value of `xPos`. Subsequent reads from it will return its default value.
  public mutating func clearXPos() {self._xPos = nil}

  /// vertical touch position, available only if touch state is TOUCH_STATE_START or TOUCH_STATE_POSITION
  public var yPos: Protocol_PbPFtpTouchPosition {
    get {return _yPos ?? Protocol_PbPFtpTouchPosition()}
    set {_yPos = newValue}
  }
  /// Returns true if `yPos` has been explicitly set.
  public var hasYPos: Bool {return self._yPos != nil}
  /// Clears the value of `yPos`. Subsequent reads from it will return its default value.
  public mutating func clearYPos() {self._yPos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PbPFtpTouchState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// touch started
    case touchStateStart // = 0

    /// touch position update
    case touchStatePosition // = 1

    /// touch ended
    case touchStateEnd // = 2

    public init() {
      self = .touchStateStart
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .touchStateStart
      case 1: self = .touchStatePosition
      case 2: self = .touchStateEnd
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .touchStateStart: return 0
      case .touchStatePosition: return 1
      case .touchStateEnd: return 2
      }
    }

  }

  public init() {}

  fileprivate var _state: Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState? = nil
  fileprivate var _xPos: Protocol_PbPFtpTouchPosition? = nil
  fileprivate var _yPos: Protocol_PbPFtpTouchPosition? = nil
}

#if swift(>=4.2)

extension Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Parameters for STOP_SYNC host to device notification.
public struct Protocol_PbPFtpStopSyncParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the host considers the synchronization completed, or false if the synchronization was interrupted.
  public var completed: Bool {
    get {return _completed ?? false}
    set {_completed = newValue}
  }
  /// Returns true if `completed` has been explicitly set.
  public var hasCompleted: Bool {return self._completed != nil}
  /// Clears the value of `completed`. Subsequent reads from it will return its default value.
  public mutating func clearCompleted() {self._completed = nil}

  ///description of the failed synchronization
  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _completed: Bool? = nil
  fileprivate var _description_p: String? = nil
}

///
/// Parameters for RESET host to device notification.
public struct Protocol_PbPFtpFactoryResetParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true the device should go to sleep (shelf mode) after the factory reset.
  public var sleep: Bool {
    get {return _sleep ?? false}
    set {_sleep = newValue}
  }
  /// Returns true if `sleep` has been explicitly set.
  public var hasSleep: Bool {return self._sleep != nil}
  /// Clears the value of `sleep`. Subsequent reads from it will return its default value.
  public mutating func clearSleep() {self._sleep = nil}

  public var doFactoryDefaults: Bool {
    get {return _doFactoryDefaults ?? true}
    set {_doFactoryDefaults = newValue}
  }
  /// Returns true if `doFactoryDefaults` has been explicitly set.
  public var hasDoFactoryDefaults: Bool {return self._doFactoryDefaults != nil}
  /// Clears the value of `doFactoryDefaults`. Subsequent reads from it will return its default value.
  public mutating func clearDoFactoryDefaults() {self._doFactoryDefaults = nil}

  ///bool ota_fwupdate added to be used during firmware update over ble.
  ///for example on Archer, if do_factory_defaults is true and ota_update true, training computer does factory defaults, but
  ///preserves bluetooth pairing info, and establishes the ble connection automatically after reset(long Back-button functionality)
  ///without showing user the "Choose language" -dialog.
  public var otaFwupdate: Bool {
    get {return _otaFwupdate ?? false}
    set {_otaFwupdate = newValue}
  }
  /// Returns true if `otaFwupdate` has been explicitly set.
  public var hasOtaFwupdate: Bool {return self._otaFwupdate != nil}
  /// Clears the value of `otaFwupdate`. Subsequent reads from it will return its default value.
  public mutating func clearOtaFwupdate() {self._otaFwupdate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sleep: Bool? = nil
  fileprivate var _doFactoryDefaults: Bool? = nil
  fileprivate var _otaFwupdate: Bool? = nil
}

///
/// Parameters for START_AUTOSYNC host to device notification.
public struct Protocol_PbPFtpStartAutosyncParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///device will try connection for time defined in timeout
  public var timeout: UInt32 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: UInt32? = nil
}

/// Host to device notification attribute 
public struct Protocol_PbPftpPnsHDAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_PbPftpPnsHDAttributeType {
    get {return _type ?? .title}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  ///
  /// Used to send total length of attribute data.
  /// Eg when we receive just part of email this is used to store total length of mail.
  public var attributeFullSize: UInt32 {
    get {return _attributeFullSize ?? 0}
    set {_attributeFullSize = newValue}
  }
  /// Returns true if `attributeFullSize` has been explicitly set.
  public var hasAttributeFullSize: Bool {return self._attributeFullSize != nil}
  /// Clears the value of `attributeFullSize`. Subsequent reads from it will return its default value.
  public mutating func clearAttributeFullSize() {self._attributeFullSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Protocol_PbPftpPnsHDAttributeType? = nil
  fileprivate var _data: String? = nil
  fileprivate var _attributeFullSize: UInt32? = nil
}

public struct Protocol_PbPftpPnsHDNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationID: UInt32 {
    get {return _notificationID ?? 0}
    set {_notificationID = newValue}
  }
  /// Returns true if `notificationID` has been explicitly set.
  public var hasNotificationID: Bool {return self._notificationID != nil}
  /// Clears the value of `notificationID`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationID() {self._notificationID = nil}

  public var categoryID: Protocol_PbPftpPnsHDCategoryID {
    get {return _categoryID ?? .categoryIDOther}
    set {_categoryID = newValue}
  }
  /// Returns true if `categoryID` has been explicitly set.
  public var hasCategoryID: Bool {return self._categoryID != nil}
  /// Clears the value of `categoryID`. Subsequent reads from it will return its default value.
  public mutating func clearCategoryID() {self._categoryID = nil}

  public var action: Protocol_Action {
    get {return _action ?? .created}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var issueTime: PbLocalDateTime {
    get {return _issueTime ?? PbLocalDateTime()}
    set {_issueTime = newValue}
  }
  /// Returns true if `issueTime` has been explicitly set.
  public var hasIssueTime: Bool {return self._issueTime != nil}
  /// Clears the value of `issueTime`. Subsequent reads from it will return its default value.
  public mutating func clearIssueTime() {self._issueTime = nil}

  public var newSameCategoryNotifications: UInt32 {
    get {return _newSameCategoryNotifications ?? 0}
    set {_newSameCategoryNotifications = newValue}
  }
  /// Returns true if `newSameCategoryNotifications` has been explicitly set.
  public var hasNewSameCategoryNotifications: Bool {return self._newSameCategoryNotifications != nil}
  /// Clears the value of `newSameCategoryNotifications`. Subsequent reads from it will return its default value.
  public mutating func clearNewSameCategoryNotifications() {self._newSameCategoryNotifications = nil}

  public var unreadSameCategoryNotifications: UInt32 {
    get {return _unreadSameCategoryNotifications ?? 0}
    set {_unreadSameCategoryNotifications = newValue}
  }
  /// Returns true if `unreadSameCategoryNotifications` has been explicitly set.
  public var hasUnreadSameCategoryNotifications: Bool {return self._unreadSameCategoryNotifications != nil}
  /// Clears the value of `unreadSameCategoryNotifications`. Subsequent reads from it will return its default value.
  public mutating func clearUnreadSameCategoryNotifications() {self._unreadSameCategoryNotifications = nil}

  public var attributes: [Protocol_PbPftpPnsHDAttribute] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notificationID: UInt32? = nil
  fileprivate var _categoryID: Protocol_PbPftpPnsHDCategoryID? = nil
  fileprivate var _action: Protocol_Action? = nil
  fileprivate var _issueTime: PbLocalDateTime? = nil
  fileprivate var _newSameCategoryNotifications: UInt32? = nil
  fileprivate var _unreadSameCategoryNotifications: UInt32? = nil
}

///
/// Parameters for GPS_DATA host to device notification.
public struct Protocol_PbPFtpGPSDataParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// latitude in degrees, value is positive on northern hemisphere
  public var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  public var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  public mutating func clearLatitude() {self._latitude = nil}

  /// longitude in degrees, value is positive on eastern hemisphere
  public var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  public var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  public mutating func clearLongitude() {self._longitude = nil}

  public var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  public var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  public mutating func clearSpeed() {self._speed = nil}

  /// total distance since receiving of START_GPS_MEASUREMENT message
  public var distance: Float {
    get {return _distance ?? 0}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  public var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  public mutating func clearDistance() {self._distance = nil}

  public var altitude: Float {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  public var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  public mutating func clearAltitude() {self._altitude = nil}

  /// number of satellites
  public var satelliteAmount: UInt32 {
    get {return _satelliteAmount ?? 0}
    set {_satelliteAmount = newValue}
  }
  /// Returns true if `satelliteAmount` has been explicitly set.
  public var hasSatelliteAmount: Bool {return self._satelliteAmount != nil}
  /// Clears the value of `satelliteAmount`. Subsequent reads from it will return its default value.
  public mutating func clearSatelliteAmount() {self._satelliteAmount = nil}

  /// Time offset in relation to start time of GPS measurement
  /// range [0 - 359999999] (ms), i.e. 00:00:00.000 - 99:59:59.999
  public var timeOffset: UInt32 {
    get {return _timeOffset ?? 0}
    set {_timeOffset = newValue}
  }
  /// Returns true if `timeOffset` has been explicitly set.
  public var hasTimeOffset: Bool {return self._timeOffset != nil}
  /// Clears the value of `timeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOffset() {self._timeOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _speed: Float? = nil
  fileprivate var _distance: Float? = nil
  fileprivate var _altitude: Float? = nil
  fileprivate var _satelliteAmount: UInt32? = nil
  fileprivate var _timeOffset: UInt32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_PbPFtpDevToHostNotification: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILESYSTEM_MODIFIED"),
    1: .same(proto: "INTERNAL_TEST_EVENT"),
    2: .same(proto: "IDLING"),
    3: .same(proto: "BATTERY_STATUS"),
    4: .same(proto: "INACTIVITY_ALERT"),
    5: .same(proto: "TRAINING_SESSION_STATUS"),
    7: .same(proto: "SYNC_REQUIRED"),
    8: .same(proto: "AUTOSYNC_STATUS"),
    9: .same(proto: "PNS_DH_NOTIFICATION_RESPONSE"),
    10: .same(proto: "PNS_SETTINGS"),
    11: .same(proto: "START_GPS_MEASUREMENT"),
    12: .same(proto: "STOP_GPS_MEASUREMENT"),
    13: .same(proto: "KEEP_BACKGROUND_ALIVE"),
    14: .same(proto: "POLAR_SHELL_DH_DATA"),
  ]
}

extension Protocol_Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATED"),
    1: .same(proto: "UPDATED"),
    2: .same(proto: "REMOVED"),
  ]
}

extension Protocol_PbPftpPnsDHAttributeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNKNOWN_ACTION"),
    2: .same(proto: "POSITIVE_ACTION"),
    3: .same(proto: "NEGATIVE_ACTION"),
    4: .same(proto: "CLEAR_ACTION"),
    5: .same(proto: "A_ACTION"),
    6: .same(proto: "B_ACTION"),
    7: .same(proto: "C_ACTION"),
    8: .same(proto: "D_ACTION"),
  ]
}

extension Protocol_PbPFtpHostToDevNotification: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START_SYNC"),
    1: .same(proto: "STOP_SYNC"),
    2: .same(proto: "RESET"),
    3: .same(proto: "LOCK_PRODUCTION_DATA"),
    4: .same(proto: "TERMINATE_SYNC"),
    5: .same(proto: "KEEP_ALIVE"),
    6: .same(proto: "START_AUTOSYNC"),
    7: .same(proto: "PNS_HD_NOTIFICATION"),
    8: .same(proto: "INITIALIZE_SESSION"),
    9: .same(proto: "TERMINATE_SESSION"),
    10: .same(proto: "SIMULATE_BUTTON_PRESS"),
    11: .same(proto: "SIMULATE_TOUCH_SCREEN"),
    12: .same(proto: "REQUEST_SYNC"),
    13: .same(proto: "FIRMWARE_UPDATE_AVAILABLE"),
    14: .same(proto: "GPS_DATA"),
    15: .same(proto: "GPS_LOST"),
    16: .same(proto: "GPS_NO_PERMISSION"),
    17: .same(proto: "POLAR_SHELL_HD_DATA"),
  ]
}

extension Protocol_PbPftpPnsHDCategoryID: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CATEGORY_ID_OTHER"),
    1: .same(proto: "CATEGORY_ID_POLAR"),
    2: .same(proto: "CATEGORY_ID_INCOMINGCALL"),
    3: .same(proto: "CATEGORY_ID_MISSEDCALL"),
    4: .same(proto: "CATEGORY_ID_VOICEMAIL"),
    5: .same(proto: "CATEGORY_ID_SOCIAL"),
    6: .same(proto: "CATEGORY_ID_SCHEDULE"),
    7: .same(proto: "CATEGORY_ID_EMAIL"),
    8: .same(proto: "CATEGORY_ID_NEWS"),
    9: .same(proto: "CATEGORY_ID_HEALTHANDFITNESS"),
    10: .same(proto: "CATEGORY_ID_BUSINESSANDFINANCE"),
    11: .same(proto: "CATEGORY_ID_LOCATION"),
    12: .same(proto: "CATEGORY_ID_ENTERTAINMENT"),
    13: .same(proto: "CATEGORY_ID_ALARM"),
    14: .same(proto: "CATEGORY_ID_PROMO"),
    15: .same(proto: "CATEGORY_ID_RECOMMENDATION"),
    16: .same(proto: "CATEGORY_ID_STATUS"),
    17: .same(proto: "CATEGORY_ID_TRANSPORT"),
  ]
}

extension Protocol_PbPftpPnsHDAttributeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TITLE"),
    1: .same(proto: "SUBTITLE"),
    2: .same(proto: "MESSAGE"),
    3: .same(proto: "POSITIVE_ACTION_LABEL"),
    4: .same(proto: "NEGATIVE_ACTION_LABEL"),
    5: .same(proto: "APPLICATION_NAME"),
    6: .same(proto: "CLEAR_ACTION_LABEL"),
    7: .same(proto: "A_ACTION_LABEL"),
    8: .same(proto: "B_ACTION_LABEL"),
    9: .same(proto: "C_ACTION_LABEL"),
    10: .same(proto: "D_ACTION_LABEL"),
  ]
}

extension Protocol_PbPFtpFilesystemModifiedParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpFilesystemModifiedParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "path"),
  ]

  public var isInitialized: Bool {
    if self._action == nil {return false}
    if self._path == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpFilesystemModifiedParams, rhs: Protocol_PbPFtpFilesystemModifiedParams) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpInactivityAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpInactivityAlert"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countdown"),
  ]

  public var isInitialized: Bool {
    if self._countdown == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._countdown) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._countdown {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpInactivityAlert, rhs: Protocol_PbPFtpInactivityAlert) -> Bool {
    if lhs._countdown != rhs._countdown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpTrainingSessionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpTrainingSessionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inprogress"),
  ]

  public var isInitialized: Bool {
    if self._inprogress == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._inprogress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inprogress {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpTrainingSessionStatus, rhs: Protocol_PbPFtpTrainingSessionStatus) -> Bool {
    if lhs._inprogress != rhs._inprogress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpAutoSyncStatusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpAutoSyncStatusParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "succeeded"),
    2: .same(proto: "description"),
  ]

  public var isInitialized: Bool {
    if self._succeeded == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._succeeded) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._succeeded {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpAutoSyncStatusParams, rhs: Protocol_PbPFtpAutoSyncStatusParams) -> Bool {
    if lhs._succeeded != rhs._succeeded {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpPolarShellMessageParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpPolarShellMessageParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "polarShellMsgId"),
    2: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._polarShellMsgID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._polarShellMsgID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._polarShellMsgID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpPolarShellMessageParams, rhs: Protocol_PbPFtpPolarShellMessageParams) -> Bool {
    if lhs._polarShellMsgID != rhs._polarShellMsgID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsDHAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPftpPnsDHAttribute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPftpPnsDHAttribute, rhs: Protocol_PbPftpPnsDHAttribute) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsDHNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPftpPnsDHNotificationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_id"),
    2: .same(proto: "attributes"),
  ]

  public var isInitialized: Bool {
    if self._notificationID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attributes) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._notificationID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPftpPnsDHNotificationResponse, rhs: Protocol_PbPftpPnsDHNotificationResponse) -> Bool {
    if lhs._notificationID != rhs._notificationID {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPftpPnsState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notifications_enabled"),
    2: .standard(proto: "preview_enabled"),
  ]

  public var isInitialized: Bool {
    if self._notificationsEnabled == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._notificationsEnabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._previewEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationsEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._previewEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPftpPnsState, rhs: Protocol_PbPftpPnsState) -> Bool {
    if lhs._notificationsEnabled != rhs._notificationsEnabled {return false}
    if lhs._previewEnabled != rhs._previewEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpStartGPSMeasurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPftpStartGPSMeasurement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_interval"),
    2: .same(proto: "accuracy"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._minimumInterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._accuracy) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minimumInterval {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accuracy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPftpStartGPSMeasurement, rhs: Protocol_PbPftpStartGPSMeasurement) -> Bool {
    if lhs._minimumInterval != rhs._minimumInterval {return false}
    if lhs._accuracy != rhs._accuracy {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbInitializeSessionParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbInitializeSessionParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "uses_attribute_level_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._usesAttributeLevelResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._usesAttributeLevelResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbInitializeSessionParams, rhs: Protocol_PbInitializeSessionParams) -> Bool {
    if lhs._usesAttributeLevelResponse != rhs._usesAttributeLevelResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbFirmwareUpdateAvailableParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbFirmwareUpdateAvailableParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mandatory"),
  ]

  public var isInitialized: Bool {
    if self._mandatory == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._mandatory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mandatory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbFirmwareUpdateAvailableParams, rhs: Protocol_PbFirmwareUpdateAvailableParams) -> Bool {
    if lhs._mandatory != rhs._mandatory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSimulateButtonPressParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpSimulateButtonPressParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "button"),
    2: .same(proto: "state"),
  ]

  public var isInitialized: Bool {
    if self._button == nil {return false}
    if self._state == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._button) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._button {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpSimulateButtonPressParams, rhs: Protocol_PbPFtpSimulateButtonPressParams) -> Bool {
    if lhs._button != rhs._button {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpTouchPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpTouchPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .standard(proto: "max_pos"),
  ]

  public var isInitialized: Bool {
    if self._pos == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._maxPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxPos {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpTouchPosition, rhs: Protocol_PbPFtpTouchPosition) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs._maxPos != rhs._maxPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSimulateTouchScreenParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpSimulateTouchScreenParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "x_pos"),
    3: .standard(proto: "y_pos"),
  ]

  public var isInitialized: Bool {
    if self._state == nil {return false}
    if let v = self._xPos, !v.isInitialized {return false}
    if let v = self._yPos, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._xPos) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._yPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._xPos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._yPos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpSimulateTouchScreenParams, rhs: Protocol_PbPFtpSimulateTouchScreenParams) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs._xPos != rhs._xPos {return false}
    if lhs._yPos != rhs._yPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOUCH_STATE_START"),
    1: .same(proto: "TOUCH_STATE_POSITION"),
    2: .same(proto: "TOUCH_STATE_END"),
  ]
}

extension Protocol_PbPFtpStopSyncParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpStopSyncParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "completed"),
    2: .same(proto: "description"),
  ]

  public var isInitialized: Bool {
    if self._completed == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._completed) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._completed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpStopSyncParams, rhs: Protocol_PbPFtpStopSyncParams) -> Bool {
    if lhs._completed != rhs._completed {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpFactoryResetParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpFactoryResetParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sleep"),
    2: .standard(proto: "do_factory_defaults"),
    3: .standard(proto: "ota_fwupdate"),
  ]

  public var isInitialized: Bool {
    if self._sleep == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._sleep) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._doFactoryDefaults) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._otaFwupdate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sleep {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._doFactoryDefaults {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._otaFwupdate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpFactoryResetParams, rhs: Protocol_PbPFtpFactoryResetParams) -> Bool {
    if lhs._sleep != rhs._sleep {return false}
    if lhs._doFactoryDefaults != rhs._doFactoryDefaults {return false}
    if lhs._otaFwupdate != rhs._otaFwupdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpStartAutosyncParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpStartAutosyncParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
  ]

  public var isInitialized: Bool {
    if self._timeout == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeout {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpStartAutosyncParams, rhs: Protocol_PbPFtpStartAutosyncParams) -> Bool {
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsHDAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPftpPnsHDAttribute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "data"),
    3: .standard(proto: "attribute_full_size"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._attributeFullSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._attributeFullSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPftpPnsHDAttribute, rhs: Protocol_PbPftpPnsHDAttribute) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._data != rhs._data {return false}
    if lhs._attributeFullSize != rhs._attributeFullSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsHDNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPftpPnsHDNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_id"),
    2: .standard(proto: "category_id"),
    3: .same(proto: "action"),
    4: .standard(proto: "issue_time"),
    5: .standard(proto: "new_same_category_notifications"),
    6: .standard(proto: "unread_same_category_notifications"),
    7: .same(proto: "attributes"),
  ]

  public var isInitialized: Bool {
    if self._notificationID == nil {return false}
    if self._categoryID == nil {return false}
    if self._action == nil {return false}
    if self._issueTime == nil {return false}
    if let v = self._issueTime, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attributes) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._notificationID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._categoryID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._issueTime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._newSameCategoryNotifications) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._unreadSameCategoryNotifications) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._categoryID {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._issueTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._newSameCategoryNotifications {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._unreadSameCategoryNotifications {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPftpPnsHDNotification, rhs: Protocol_PbPftpPnsHDNotification) -> Bool {
    if lhs._notificationID != rhs._notificationID {return false}
    if lhs._categoryID != rhs._categoryID {return false}
    if lhs._action != rhs._action {return false}
    if lhs._issueTime != rhs._issueTime {return false}
    if lhs._newSameCategoryNotifications != rhs._newSameCategoryNotifications {return false}
    if lhs._unreadSameCategoryNotifications != rhs._unreadSameCategoryNotifications {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGPSDataParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPFtpGPSDataParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "speed"),
    4: .same(proto: "distance"),
    5: .same(proto: "altitude"),
    6: .standard(proto: "satellite_amount"),
    7: .standard(proto: "time_offset"),
  ]

  public var isInitialized: Bool {
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._speed) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._distance) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._altitude) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._satelliteAmount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._timeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._altitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._satelliteAmount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeOffset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PbPFtpGPSDataParams, rhs: Protocol_PbPFtpGPSDataParams) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs._satelliteAmount != rhs._satelliteAmount {return false}
    if lhs._timeOffset != rhs._timeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
