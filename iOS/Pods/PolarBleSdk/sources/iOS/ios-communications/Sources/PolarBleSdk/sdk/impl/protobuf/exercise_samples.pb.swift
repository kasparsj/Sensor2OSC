// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exercise_samples.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// SAMPLES.BPB=PbExerciseSamples

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
///Power data from crank based power sensors
///See: https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.cycling_power_measurement.xml
public struct Data_PbPowerMeasurements {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Instantaneous power
  public var currentPower: Int32 {
    get {return _currentPower ?? 0}
    set {_currentPower = newValue}
  }
  /// Returns true if `currentPower` has been explicitly set.
  public var hasCurrentPower: Bool {return self._currentPower != nil}
  /// Clears the value of `currentPower`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPower() {self._currentPower = nil}

  /// Cumulative crank revolutions starting from the first stored sample data
  /// This is originally overflowing 16 bit unsigned int value
  /// This value do not necessarily change for every vector data set
  /// This value is not necessarily provided for every vector data set
  public var cumulativeCrankRevolutions: UInt32 {
    get {return _cumulativeCrankRevolutions ?? 0}
    set {_cumulativeCrankRevolutions = newValue}
  }
  /// Returns true if `cumulativeCrankRevolutions` has been explicitly set.
  public var hasCumulativeCrankRevolutions: Bool {return self._cumulativeCrankRevolutions != nil}
  /// Clears the value of `cumulativeCrankRevolutions`. Subsequent reads from it will return its default value.
  public mutating func clearCumulativeCrankRevolutions() {self._cumulativeCrankRevolutions = nil}

  /// Cumulative timestamp in milliseconds starting from the first stored sample data
  /// Originally overflowing uint16 value, [1/1024 of second]
  /// This value do not necessarily change for every vector data set
  /// This value is not necessarily provided for every vector data set
  public var cumulativeTimestamp: UInt32 {
    get {return _cumulativeTimestamp ?? 0}
    set {_cumulativeTimestamp = newValue}
  }
  /// Returns true if `cumulativeTimestamp` has been explicitly set.
  public var hasCumulativeTimestamp: Bool {return self._cumulativeTimestamp != nil}
  /// Clears the value of `cumulativeTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearCumulativeTimestamp() {self._cumulativeTimestamp = nil}

  /// Minimum force magnitude power
  public var forceMagnitudeMin: Int32 {
    get {return _forceMagnitudeMin ?? 0}
    set {_forceMagnitudeMin = newValue}
  }
  /// Returns true if `forceMagnitudeMin` has been explicitly set.
  public var hasForceMagnitudeMin: Bool {return self._forceMagnitudeMin != nil}
  /// Clears the value of `forceMagnitudeMin`. Subsequent reads from it will return its default value.
  public mutating func clearForceMagnitudeMin() {self._forceMagnitudeMin = nil}

  /// Maximum force magnitude power
  public var forceMagnitudeMax: Int32 {
    get {return _forceMagnitudeMax ?? 0}
    set {_forceMagnitudeMax = newValue}
  }
  /// Returns true if `forceMagnitudeMax` has been explicitly set.
  public var hasForceMagnitudeMax: Bool {return self._forceMagnitudeMax != nil}
  /// Clears the value of `forceMagnitudeMax`. Subsequent reads from it will return its default value.
  public mutating func clearForceMagnitudeMax() {self._forceMagnitudeMax = nil}

  /// Minimum force magnitude angle
  /// Counted clockwise, topmost position is 0 degrees, view point is right side of the bike for both pedals
  public var forceMagnitudeMinAngle: UInt32 {
    get {return _forceMagnitudeMinAngle ?? 0}
    set {_forceMagnitudeMinAngle = newValue}
  }
  /// Returns true if `forceMagnitudeMinAngle` has been explicitly set.
  public var hasForceMagnitudeMinAngle: Bool {return self._forceMagnitudeMinAngle != nil}
  /// Clears the value of `forceMagnitudeMinAngle`. Subsequent reads from it will return its default value.
  public mutating func clearForceMagnitudeMinAngle() {self._forceMagnitudeMinAngle = nil}

  /// Maximum force magnitude angle
  /// Counted clockwise, topmost position is 0 degrees, view point is right side of the bike for both pedals
  public var forceMagnitudeMaxAngle: UInt32 {
    get {return _forceMagnitudeMaxAngle ?? 0}
    set {_forceMagnitudeMaxAngle = newValue}
  }
  /// Returns true if `forceMagnitudeMaxAngle` has been explicitly set.
  public var hasForceMagnitudeMaxAngle: Bool {return self._forceMagnitudeMaxAngle != nil}
  /// Clears the value of `forceMagnitudeMaxAngle`. Subsequent reads from it will return its default value.
  public mutating func clearForceMagnitudeMaxAngle() {self._forceMagnitudeMaxAngle = nil}

  /// Dead spot bottom angle
  /// Counted clockwise, topmost position is 0 degrees, view point is right side of the bike for both pedals
  public var bottomDeadSpotAngle: UInt32 {
    get {return _bottomDeadSpotAngle ?? 0}
    set {_bottomDeadSpotAngle = newValue}
  }
  /// Returns true if `bottomDeadSpotAngle` has been explicitly set.
  public var hasBottomDeadSpotAngle: Bool {return self._bottomDeadSpotAngle != nil}
  /// Clears the value of `bottomDeadSpotAngle`. Subsequent reads from it will return its default value.
  public mutating func clearBottomDeadSpotAngle() {self._bottomDeadSpotAngle = nil}

  /// Dead spot top angle
  /// Counted clockwise, topmost position is 0 degrees, view point is right side of the bike for both pedals
  public var topDeadSpotAngle: UInt32 {
    get {return _topDeadSpotAngle ?? 0}
    set {_topDeadSpotAngle = newValue}
  }
  /// Returns true if `topDeadSpotAngle` has been explicitly set.
  public var hasTopDeadSpotAngle: Bool {return self._topDeadSpotAngle != nil}
  /// Clears the value of `topDeadSpotAngle`. Subsequent reads from it will return its default value.
  public mutating func clearTopDeadSpotAngle() {self._topDeadSpotAngle = nil}

  ///Unit is in percentage with a resolution of 1/2. Left foot power percentage of total power. 
  ///pedal_power_balance = [LeftPower/(LeftPower + RightPower)]*100
  public var pedalPowerBalance: UInt32 {
    get {return _pedalPowerBalance ?? 0}
    set {_pedalPowerBalance = newValue}
  }
  /// Returns true if `pedalPowerBalance` has been explicitly set.
  public var hasPedalPowerBalance: Bool {return self._pedalPowerBalance != nil}
  /// Clears the value of `pedalPowerBalance`. Subsequent reads from it will return its default value.
  public mutating func clearPedalPowerBalance() {self._pedalPowerBalance = nil}

  ///Unit is in newton metres with a resolution of 1/32.
  public var torqueMagnitudeMin: Int32 {
    get {return _torqueMagnitudeMin ?? 0}
    set {_torqueMagnitudeMin = newValue}
  }
  /// Returns true if `torqueMagnitudeMin` has been explicitly set.
  public var hasTorqueMagnitudeMin: Bool {return self._torqueMagnitudeMin != nil}
  /// Clears the value of `torqueMagnitudeMin`. Subsequent reads from it will return its default value.
  public mutating func clearTorqueMagnitudeMin() {self._torqueMagnitudeMin = nil}

  ///Unit is in newton metres with a resolution of 1/32.
  public var torqueMagnitudeMax: Int32 {
    get {return _torqueMagnitudeMax ?? 0}
    set {_torqueMagnitudeMax = newValue}
  }
  /// Returns true if `torqueMagnitudeMax` has been explicitly set.
  public var hasTorqueMagnitudeMax: Bool {return self._torqueMagnitudeMax != nil}
  /// Clears the value of `torqueMagnitudeMax`. Subsequent reads from it will return its default value.
  public mutating func clearTorqueMagnitudeMax() {self._torqueMagnitudeMax = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentPower: Int32? = nil
  fileprivate var _cumulativeCrankRevolutions: UInt32? = nil
  fileprivate var _cumulativeTimestamp: UInt32? = nil
  fileprivate var _forceMagnitudeMin: Int32? = nil
  fileprivate var _forceMagnitudeMax: Int32? = nil
  fileprivate var _forceMagnitudeMinAngle: UInt32? = nil
  fileprivate var _forceMagnitudeMaxAngle: UInt32? = nil
  fileprivate var _bottomDeadSpotAngle: UInt32? = nil
  fileprivate var _topDeadSpotAngle: UInt32? = nil
  fileprivate var _pedalPowerBalance: UInt32? = nil
  fileprivate var _torqueMagnitudeMin: Int32? = nil
  fileprivate var _torqueMagnitudeMax: Int32? = nil
}

///
///Sample data calibration value of the exercise
public struct Data_PbCalibrationValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// index of first sample using calibration value "value"
  public var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  public var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStartIndex() {self._startIndex = nil}

  /// used calibaration value
  public var value: Float {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// used operation type of calibration (multiply/sum)
  public var operation: PbOperationType {
    get {return _operation ?? .multiply}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  public var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  public mutating func clearOperation() {self._operation = nil}

  /// explaines the cause for calibration change (walking/running)
  public var cause: PbMovingType {
    get {return _cause ?? .walking}
    set {_cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  public var hasCause: Bool {return self._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  public mutating func clearCause() {self._cause = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startIndex: UInt32? = nil
  fileprivate var _value: Float? = nil
  fileprivate var _operation: PbOperationType? = nil
  fileprivate var _cause: PbMovingType? = nil
}

///
///Exercise samples with sample type specific recording intervals
public struct Data_PbExerciseIntervalledSampleList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sample Type, SPEED, DISTANCE etc.
  public var sampleType: PbSampleType {
    get {return _storage._sampleType ?? .sampleTypeUndefined}
    set {_uniqueStorage()._sampleType = newValue}
  }
  /// Returns true if `sampleType` has been explicitly set.
  public var hasSampleType: Bool {return _storage._sampleType != nil}
  /// Clears the value of `sampleType`. Subsequent reads from it will return its default value.
  public mutating func clearSampleType() {_uniqueStorage()._sampleType = nil}

  /// Recording interval of samples in milliseconds
  /// Note: When this field is set, it will override the default recording interval
  ///       (PbDuration recording_interval) given in the PbExerciseSamples message   
  public var recordingIntervalMs: UInt32 {
    get {return _storage._recordingIntervalMs ?? 0}
    set {_uniqueStorage()._recordingIntervalMs = newValue}
  }
  /// Returns true if `recordingIntervalMs` has been explicitly set.
  public var hasRecordingIntervalMs: Bool {return _storage._recordingIntervalMs != nil}
  /// Clears the value of `recordingIntervalMs`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingIntervalMs() {_uniqueStorage()._recordingIntervalMs = nil}

  /// Indicates the source of certain sample: source and start / stop indexes for the given source
  public var sampleSource: [PbSampleSource] {
    get {return _storage._sampleSource}
    set {_uniqueStorage()._sampleSource = newValue}
  }

  /// heart rate samples
  public var heartRateSamples: [UInt32] {
    get {return _storage._heartRateSamples}
    set {_uniqueStorage()._heartRateSamples = newValue}
  }

  /// cadence samples
  public var cadenceSamples: [UInt32] {
    get {return _storage._cadenceSamples}
    set {_uniqueStorage()._cadenceSamples = newValue}
  }

  /// speed samples
  /// Note: Samples are already calibrated samples
  public var speedSamples: [Float] {
    get {return _storage._speedSamples}
    set {_uniqueStorage()._speedSamples = newValue}
  }

  /// distance samples: total distance from the beginning of the exercise
  /// Note: Samples are already calibrated samples
  public var distanceSamples: [Float] {
    get {return _storage._distanceSamples}
    set {_uniqueStorage()._distanceSamples = newValue}
  }

  /// User 1d acceleration samples as m/s2
  public var forwardAcceleration: [Float] {
    get {return _storage._forwardAcceleration}
    set {_uniqueStorage()._forwardAcceleration = newValue}
  }

  /// User walking/running/standing status samples
  public var movingTypeSamples: [PbMovingType] {
    get {return _storage._movingTypeSamples}
    set {_uniqueStorage()._movingTypeSamples = newValue}
  }

  /// altitude samples
  /// Note: Samples are already calibrated samples
  public var altitudeSamples: [Float] {
    get {return _storage._altitudeSamples}
    set {_uniqueStorage()._altitudeSamples = newValue}
  }

  /// indicate start and stop indexes, used calibration value and operation type of calibration
  public var altitudeCalibration: [Data_PbCalibrationValue] {
    get {return _storage._altitudeCalibration}
    set {_uniqueStorage()._altitudeCalibration = newValue}
  }

  /// temperature samples
  public var temperatureSamples: [Float] {
    get {return _storage._temperatureSamples}
    set {_uniqueStorage()._temperatureSamples = newValue}
  }

  /// stride length samples
  /// Note: Samples are already calibrated samples
  public var strideLengthSamples: [UInt32] {
    get {return _storage._strideLengthSamples}
    set {_uniqueStorage()._strideLengthSamples = newValue}
  }

  /// indicate the information of the stride sensor calibration
  public var strideCalibration: [Data_PbCalibrationValue] {
    get {return _storage._strideCalibration}
    set {_uniqueStorage()._strideCalibration = newValue}
  }

  /// Crank based power samples from left pedal
  public var leftPedalPowerSamples: [Data_PbPowerMeasurements] {
    get {return _storage._leftPedalPowerSamples}
    set {_uniqueStorage()._leftPedalPowerSamples = newValue}
  }

  /// Crank based power samples from right pedal
  public var rightPedalPowerSamples: [Data_PbPowerMeasurements] {
    get {return _storage._rightPedalPowerSamples}
    set {_uniqueStorage()._rightPedalPowerSamples = newValue}
  }

  /// Indicate the information of the bike power sensor calibration
  /// This field is most likely used only for testing purposes
  public var leftPowerCalibration: [Data_PbCalibrationValue] {
    get {return _storage._leftPowerCalibration}
    set {_uniqueStorage()._leftPowerCalibration = newValue}
  }

  /// Indicate the information of the bike power sensor calibration 
  /// This field is most likely used only for testing purposes
  public var rightPowerCalibration: [Data_PbCalibrationValue] {
    get {return _storage._rightPowerCalibration}
    set {_uniqueStorage()._rightPowerCalibration = newValue}
  }

  /// Heart Rate R-R sample data.
  public var rrSamples: Data_PbExerciseRRIntervals {
    get {return _storage._rrSamples ?? Data_PbExerciseRRIntervals()}
    set {_uniqueStorage()._rrSamples = newValue}
  }
  /// Returns true if `rrSamples` has been explicitly set.
  public var hasRrSamples: Bool {return _storage._rrSamples != nil}
  /// Clears the value of `rrSamples`. Subsequent reads from it will return its default value.
  public mutating func clearRrSamples() {_uniqueStorage()._rrSamples = nil}

  /// Acceleration based Mean Amplitude Deviation (MAD) samples
  public var accelerationMadSamples: [Float] {
    get {return _storage._accelerationMadSamples}
    set {_uniqueStorage()._accelerationMadSamples = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
///Sample data of the exercise.
///! All fields are required.
public struct Data_PbExerciseSamples {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Default recording interval of samples
  /// Note: Samples listed in the root of the PbExerciseSamples will use this interval
  /// Note: Samples in the exercise_intervalled_sample_list will use this interval unless
  ///       otherwise specified inside the exercise_intervalled_sample_list    
  public var recordingInterval: PbDuration {
    get {return _storage._recordingInterval ?? PbDuration()}
    set {_uniqueStorage()._recordingInterval = newValue}
  }
  /// Returns true if `recordingInterval` has been explicitly set.
  public var hasRecordingInterval: Bool {return _storage._recordingInterval != nil}
  /// Clears the value of `recordingInterval`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingInterval() {_uniqueStorage()._recordingInterval = nil}

  /// heart rate samples
  public var heartRateSamples: [UInt32] {
    get {return _storage._heartRateSamples}
    set {_uniqueStorage()._heartRateSamples = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to heart rate sensor
  public var heartRateOffline: [PbSensorOffline] {
    get {return _storage._heartRateOffline}
    set {_uniqueStorage()._heartRateOffline = newValue}
  }

  /// cadence samples
  public var cadenceSamples: [UInt32] {
    get {return _storage._cadenceSamples}
    set {_uniqueStorage()._cadenceSamples = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to a sensor providing cadence
  public var cadenceOffline: [PbSensorOffline] {
    get {return _storage._cadenceOffline}
    set {_uniqueStorage()._cadenceOffline = newValue}
  }

  /// altitude samples
  /// Note: Samples are already calibrated samples
  public var altitudeSamples: [Float] {
    get {return _storage._altitudeSamples}
    set {_uniqueStorage()._altitudeSamples = newValue}
  }

  /// Altitude sensor offline status
  public var altitudeOffline: [PbSensorOffline] {
    get {return _storage._altitudeOffline}
    set {_uniqueStorage()._altitudeOffline = newValue}
  }

  /// indicate start and stop indexes, used calibration value and operation type of calibration
  public var altitudeCalibration: [Data_PbCalibrationValue] {
    get {return _storage._altitudeCalibration}
    set {_uniqueStorage()._altitudeCalibration = newValue}
  }

  /// temperature samples
  public var temperatureSamples: [Float] {
    get {return _storage._temperatureSamples}
    set {_uniqueStorage()._temperatureSamples = newValue}
  }

  /// Temperature sensor offline status
  public var temperatureOffline: [PbSensorOffline] {
    get {return _storage._temperatureOffline}
    set {_uniqueStorage()._temperatureOffline = newValue}
  }

  /// speed samples
  /// Note: Samples are already calibrated samples
  public var speedSamples: [Float] {
    get {return _storage._speedSamples}
    set {_uniqueStorage()._speedSamples = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to speed sensor
  public var speedOffline: [PbSensorOffline] {
    get {return _storage._speedOffline}
    set {_uniqueStorage()._speedOffline = newValue}
  }

  /// distance samples: total distance from the beginning of the exercise
  /// Note: Samples are already calibrated samples
  public var distanceSamples: [Float] {
    get {return _storage._distanceSamples}
    set {_uniqueStorage()._distanceSamples = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to distance measure sensor
  public var distanceOffline: [PbSensorOffline] {
    get {return _storage._distanceOffline}
    set {_uniqueStorage()._distanceOffline = newValue}
  }

  /// stride length samples
  /// Note: Samples are already calibrated samples
  public var strideLengthSamples: [UInt32] {
    get {return _storage._strideLengthSamples}
    set {_uniqueStorage()._strideLengthSamples = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to stride sensor
  public var strideLengthOffline: [PbSensorOffline] {
    get {return _storage._strideLengthOffline}
    set {_uniqueStorage()._strideLengthOffline = newValue}
  }

  /// indicate the information of the stride sensor calibration
  public var strideCalibration: [Data_PbCalibrationValue] {
    get {return _storage._strideCalibration}
    set {_uniqueStorage()._strideCalibration = newValue}
  }

  /// User 1d acceleration samples as m/s2
  public var forwardAcceleration: [Float] {
    get {return _storage._forwardAcceleration}
    set {_uniqueStorage()._forwardAcceleration = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to sensor that produces forward acceleration
  public var forwardAccelerationOffline: [PbSensorOffline] {
    get {return _storage._forwardAccelerationOffline}
    set {_uniqueStorage()._forwardAccelerationOffline = newValue}
  }

  /// User walking/running/standing status samples
  public var movingTypeSamples: [PbMovingType] {
    get {return _storage._movingTypeSamples}
    set {_uniqueStorage()._movingTypeSamples = newValue}
  }

  /// indicate start and stop indexes when there has not been connection to sensor that produces moving_type
  public var movingTypeOffline: [PbSensorOffline] {
    get {return _storage._movingTypeOffline}
    set {_uniqueStorage()._movingTypeOffline = newValue}
  }

  /// Crank based power samples from left pedal
  public var leftPedalPowerSamples: [Data_PbPowerMeasurements] {
    get {return _storage._leftPedalPowerSamples}
    set {_uniqueStorage()._leftPedalPowerSamples = newValue}
  }

  /// Indicate start and stop indexes when there has not been connection to sensor that produces left_pedal_power_samples
  public var leftPedalPowerOffline: [PbSensorOffline] {
    get {return _storage._leftPedalPowerOffline}
    set {_uniqueStorage()._leftPedalPowerOffline = newValue}
  }

  /// Crank based power samples from right pedal
  public var rightPedalPowerSamples: [Data_PbPowerMeasurements] {
    get {return _storage._rightPedalPowerSamples}
    set {_uniqueStorage()._rightPedalPowerSamples = newValue}
  }

  /// Indicate start and stop indexes when there has not been connection to sensor that produces right_pedal_power_samples
  public var rightPedalPowerOffline: [PbSensorOffline] {
    get {return _storage._rightPedalPowerOffline}
    set {_uniqueStorage()._rightPedalPowerOffline = newValue}
  }

  /// Indicate the information of the bike power sensor calibration
  /// This field is most likely used only for testing purposes
  public var leftPowerCalibration: [Data_PbCalibrationValue] {
    get {return _storage._leftPowerCalibration}
    set {_uniqueStorage()._leftPowerCalibration = newValue}
  }

  /// Indicate the information of the bike power sensor calibration 
  /// This field is most likely used only for testing purposes
  public var rightPowerCalibration: [Data_PbCalibrationValue] {
    get {return _storage._rightPowerCalibration}
    set {_uniqueStorage()._rightPowerCalibration = newValue}
  }

  /// Heart Rate R-R sample data.
  public var rrSamples: Data_PbExerciseRRIntervals {
    get {return _storage._rrSamples ?? Data_PbExerciseRRIntervals()}
    set {_uniqueStorage()._rrSamples = newValue}
  }
  /// Returns true if `rrSamples` has been explicitly set.
  public var hasRrSamples: Bool {return _storage._rrSamples != nil}
  /// Clears the value of `rrSamples`. Subsequent reads from it will return its default value.
  public mutating func clearRrSamples() {_uniqueStorage()._rrSamples = nil}

  /// Exercise samples with sample type specific recording intervals
  public var exerciseIntervalledSampleList: [Data_PbExerciseIntervalledSampleList] {
    get {return _storage._exerciseIntervalledSampleList}
    set {_uniqueStorage()._exerciseIntervalledSampleList = newValue}
  }

  /// Exercise pause times
  public var pauseTimes: [PbPauseTime] {
    get {return _storage._pauseTimes}
    set {_uniqueStorage()._pauseTimes = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data"

extension Data_PbPowerMeasurements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbPowerMeasurements"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_power"),
    2: .standard(proto: "cumulative_crank_revolutions"),
    3: .standard(proto: "cumulative_timestamp"),
    4: .standard(proto: "force_magnitude_min"),
    5: .standard(proto: "force_magnitude_max"),
    6: .standard(proto: "force_magnitude_min_angle"),
    7: .standard(proto: "force_magnitude_max_angle"),
    8: .standard(proto: "bottom_dead_spot_angle"),
    9: .standard(proto: "top_dead_spot_angle"),
    10: .standard(proto: "pedal_power_balance"),
    11: .standard(proto: "torque_magnitude_min"),
    12: .standard(proto: "torque_magnitude_max"),
  ]

  public var isInitialized: Bool {
    if self._currentPower == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._currentPower) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cumulativeCrankRevolutions) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._cumulativeTimestamp) }()
      case 4: try { try decoder.decodeSingularSInt32Field(value: &self._forceMagnitudeMin) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._forceMagnitudeMax) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._forceMagnitudeMinAngle) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._forceMagnitudeMaxAngle) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._bottomDeadSpotAngle) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._topDeadSpotAngle) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._pedalPowerBalance) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._torqueMagnitudeMin) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self._torqueMagnitudeMax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentPower {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cumulativeCrankRevolutions {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cumulativeTimestamp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._forceMagnitudeMin {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._forceMagnitudeMax {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._forceMagnitudeMinAngle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._forceMagnitudeMaxAngle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._bottomDeadSpotAngle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._topDeadSpotAngle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._pedalPowerBalance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._torqueMagnitudeMin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._torqueMagnitudeMax {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Data_PbPowerMeasurements, rhs: Data_PbPowerMeasurements) -> Bool {
    if lhs._currentPower != rhs._currentPower {return false}
    if lhs._cumulativeCrankRevolutions != rhs._cumulativeCrankRevolutions {return false}
    if lhs._cumulativeTimestamp != rhs._cumulativeTimestamp {return false}
    if lhs._forceMagnitudeMin != rhs._forceMagnitudeMin {return false}
    if lhs._forceMagnitudeMax != rhs._forceMagnitudeMax {return false}
    if lhs._forceMagnitudeMinAngle != rhs._forceMagnitudeMinAngle {return false}
    if lhs._forceMagnitudeMaxAngle != rhs._forceMagnitudeMaxAngle {return false}
    if lhs._bottomDeadSpotAngle != rhs._bottomDeadSpotAngle {return false}
    if lhs._topDeadSpotAngle != rhs._topDeadSpotAngle {return false}
    if lhs._pedalPowerBalance != rhs._pedalPowerBalance {return false}
    if lhs._torqueMagnitudeMin != rhs._torqueMagnitudeMin {return false}
    if lhs._torqueMagnitudeMax != rhs._torqueMagnitudeMax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbCalibrationValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbCalibrationValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_index"),
    2: .same(proto: "value"),
    3: .same(proto: "operation"),
    4: .same(proto: "cause"),
  ]

  public var isInitialized: Bool {
    if self._startIndex == nil {return false}
    if self._value == nil {return false}
    if self._operation == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._cause) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cause {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Data_PbCalibrationValue, rhs: Data_PbCalibrationValue) -> Bool {
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs._value != rhs._value {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._cause != rhs._cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseIntervalledSampleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbExerciseIntervalledSampleList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .standard(proto: "recording_interval_ms"),
    3: .standard(proto: "sample_source"),
    4: .standard(proto: "heart_rate_samples"),
    5: .standard(proto: "cadence_samples"),
    6: .standard(proto: "speed_samples"),
    7: .standard(proto: "distance_samples"),
    8: .standard(proto: "forward_acceleration"),
    9: .standard(proto: "moving_type_samples"),
    10: .standard(proto: "altitude_samples"),
    11: .standard(proto: "altitude_calibration"),
    12: .standard(proto: "temperature_samples"),
    13: .standard(proto: "stride_length_samples"),
    14: .standard(proto: "stride_calibration"),
    15: .standard(proto: "left_pedal_power_samples"),
    16: .standard(proto: "right_pedal_power_samples"),
    17: .standard(proto: "left_power_calibration"),
    18: .standard(proto: "right_power_calibration"),
    19: .standard(proto: "rr_samples"),
    20: .standard(proto: "acceleration_mad_samples"),
  ]

  fileprivate class _StorageClass {
    var _sampleType: PbSampleType? = nil
    var _recordingIntervalMs: UInt32? = nil
    var _sampleSource: [PbSampleSource] = []
    var _heartRateSamples: [UInt32] = []
    var _cadenceSamples: [UInt32] = []
    var _speedSamples: [Float] = []
    var _distanceSamples: [Float] = []
    var _forwardAcceleration: [Float] = []
    var _movingTypeSamples: [PbMovingType] = []
    var _altitudeSamples: [Float] = []
    var _altitudeCalibration: [Data_PbCalibrationValue] = []
    var _temperatureSamples: [Float] = []
    var _strideLengthSamples: [UInt32] = []
    var _strideCalibration: [Data_PbCalibrationValue] = []
    var _leftPedalPowerSamples: [Data_PbPowerMeasurements] = []
    var _rightPedalPowerSamples: [Data_PbPowerMeasurements] = []
    var _leftPowerCalibration: [Data_PbCalibrationValue] = []
    var _rightPowerCalibration: [Data_PbCalibrationValue] = []
    var _rrSamples: Data_PbExerciseRRIntervals? = nil
    var _accelerationMadSamples: [Float] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sampleType = source._sampleType
      _recordingIntervalMs = source._recordingIntervalMs
      _sampleSource = source._sampleSource
      _heartRateSamples = source._heartRateSamples
      _cadenceSamples = source._cadenceSamples
      _speedSamples = source._speedSamples
      _distanceSamples = source._distanceSamples
      _forwardAcceleration = source._forwardAcceleration
      _movingTypeSamples = source._movingTypeSamples
      _altitudeSamples = source._altitudeSamples
      _altitudeCalibration = source._altitudeCalibration
      _temperatureSamples = source._temperatureSamples
      _strideLengthSamples = source._strideLengthSamples
      _strideCalibration = source._strideCalibration
      _leftPedalPowerSamples = source._leftPedalPowerSamples
      _rightPedalPowerSamples = source._rightPedalPowerSamples
      _leftPowerCalibration = source._leftPowerCalibration
      _rightPowerCalibration = source._rightPowerCalibration
      _rrSamples = source._rrSamples
      _accelerationMadSamples = source._accelerationMadSamples
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sampleType == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sampleSource) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._altitudeCalibration) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._strideCalibration) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._leftPedalPowerSamples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rightPedalPowerSamples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._leftPowerCalibration) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rightPowerCalibration) {return false}
      if let v = _storage._rrSamples, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._sampleType) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._recordingIntervalMs) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sampleSource) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._heartRateSamples) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._cadenceSamples) }()
        case 6: try { try decoder.decodeRepeatedFloatField(value: &_storage._speedSamples) }()
        case 7: try { try decoder.decodeRepeatedFloatField(value: &_storage._distanceSamples) }()
        case 8: try { try decoder.decodeRepeatedFloatField(value: &_storage._forwardAcceleration) }()
        case 9: try { try decoder.decodeRepeatedEnumField(value: &_storage._movingTypeSamples) }()
        case 10: try { try decoder.decodeRepeatedFloatField(value: &_storage._altitudeSamples) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._altitudeCalibration) }()
        case 12: try { try decoder.decodeRepeatedFloatField(value: &_storage._temperatureSamples) }()
        case 13: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._strideLengthSamples) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._strideCalibration) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._leftPedalPowerSamples) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._rightPedalPowerSamples) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._leftPowerCalibration) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._rightPowerCalibration) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._rrSamples) }()
        case 20: try { try decoder.decodeRepeatedFloatField(value: &_storage._accelerationMadSamples) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._sampleType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._recordingIntervalMs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      if !_storage._sampleSource.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sampleSource, fieldNumber: 3)
      }
      if !_storage._heartRateSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._heartRateSamples, fieldNumber: 4)
      }
      if !_storage._cadenceSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._cadenceSamples, fieldNumber: 5)
      }
      if !_storage._speedSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._speedSamples, fieldNumber: 6)
      }
      if !_storage._distanceSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._distanceSamples, fieldNumber: 7)
      }
      if !_storage._forwardAcceleration.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._forwardAcceleration, fieldNumber: 8)
      }
      if !_storage._movingTypeSamples.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._movingTypeSamples, fieldNumber: 9)
      }
      if !_storage._altitudeSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._altitudeSamples, fieldNumber: 10)
      }
      if !_storage._altitudeCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._altitudeCalibration, fieldNumber: 11)
      }
      if !_storage._temperatureSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._temperatureSamples, fieldNumber: 12)
      }
      if !_storage._strideLengthSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._strideLengthSamples, fieldNumber: 13)
      }
      if !_storage._strideCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._strideCalibration, fieldNumber: 14)
      }
      if !_storage._leftPedalPowerSamples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leftPedalPowerSamples, fieldNumber: 15)
      }
      if !_storage._rightPedalPowerSamples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rightPedalPowerSamples, fieldNumber: 16)
      }
      if !_storage._leftPowerCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leftPowerCalibration, fieldNumber: 17)
      }
      if !_storage._rightPowerCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rightPowerCalibration, fieldNumber: 18)
      }
      try { if let v = _storage._rrSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._accelerationMadSamples.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._accelerationMadSamples, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Data_PbExerciseIntervalledSampleList, rhs: Data_PbExerciseIntervalledSampleList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sampleType != rhs_storage._sampleType {return false}
        if _storage._recordingIntervalMs != rhs_storage._recordingIntervalMs {return false}
        if _storage._sampleSource != rhs_storage._sampleSource {return false}
        if _storage._heartRateSamples != rhs_storage._heartRateSamples {return false}
        if _storage._cadenceSamples != rhs_storage._cadenceSamples {return false}
        if _storage._speedSamples != rhs_storage._speedSamples {return false}
        if _storage._distanceSamples != rhs_storage._distanceSamples {return false}
        if _storage._forwardAcceleration != rhs_storage._forwardAcceleration {return false}
        if _storage._movingTypeSamples != rhs_storage._movingTypeSamples {return false}
        if _storage._altitudeSamples != rhs_storage._altitudeSamples {return false}
        if _storage._altitudeCalibration != rhs_storage._altitudeCalibration {return false}
        if _storage._temperatureSamples != rhs_storage._temperatureSamples {return false}
        if _storage._strideLengthSamples != rhs_storage._strideLengthSamples {return false}
        if _storage._strideCalibration != rhs_storage._strideCalibration {return false}
        if _storage._leftPedalPowerSamples != rhs_storage._leftPedalPowerSamples {return false}
        if _storage._rightPedalPowerSamples != rhs_storage._rightPedalPowerSamples {return false}
        if _storage._leftPowerCalibration != rhs_storage._leftPowerCalibration {return false}
        if _storage._rightPowerCalibration != rhs_storage._rightPowerCalibration {return false}
        if _storage._rrSamples != rhs_storage._rrSamples {return false}
        if _storage._accelerationMadSamples != rhs_storage._accelerationMadSamples {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseSamples: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PbExerciseSamples"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recording_interval"),
    2: .standard(proto: "heart_rate_samples"),
    3: .standard(proto: "heart_rate_offline"),
    4: .standard(proto: "cadence_samples"),
    5: .standard(proto: "cadence_offline"),
    6: .standard(proto: "altitude_samples"),
    18: .standard(proto: "altitude_offline"),
    7: .standard(proto: "altitude_calibration"),
    8: .standard(proto: "temperature_samples"),
    19: .standard(proto: "temperature_offline"),
    9: .standard(proto: "speed_samples"),
    10: .standard(proto: "speed_offline"),
    11: .standard(proto: "distance_samples"),
    12: .standard(proto: "distance_offline"),
    13: .standard(proto: "stride_length_samples"),
    14: .standard(proto: "stride_length_offline"),
    15: .standard(proto: "stride_calibration"),
    16: .standard(proto: "forward_acceleration"),
    20: .standard(proto: "forward_acceleration_offline"),
    17: .standard(proto: "moving_type_samples"),
    21: .standard(proto: "moving_type_offline"),
    22: .standard(proto: "left_pedal_power_samples"),
    23: .standard(proto: "left_pedal_power_offline"),
    24: .standard(proto: "right_pedal_power_samples"),
    25: .standard(proto: "right_pedal_power_offline"),
    26: .standard(proto: "left_power_calibration"),
    27: .standard(proto: "right_power_calibration"),
    28: .standard(proto: "rr_samples"),
    29: .standard(proto: "exercise_intervalled_sample_list"),
    30: .standard(proto: "pause_times"),
  ]

  fileprivate class _StorageClass {
    var _recordingInterval: PbDuration? = nil
    var _heartRateSamples: [UInt32] = []
    var _heartRateOffline: [PbSensorOffline] = []
    var _cadenceSamples: [UInt32] = []
    var _cadenceOffline: [PbSensorOffline] = []
    var _altitudeSamples: [Float] = []
    var _altitudeOffline: [PbSensorOffline] = []
    var _altitudeCalibration: [Data_PbCalibrationValue] = []
    var _temperatureSamples: [Float] = []
    var _temperatureOffline: [PbSensorOffline] = []
    var _speedSamples: [Float] = []
    var _speedOffline: [PbSensorOffline] = []
    var _distanceSamples: [Float] = []
    var _distanceOffline: [PbSensorOffline] = []
    var _strideLengthSamples: [UInt32] = []
    var _strideLengthOffline: [PbSensorOffline] = []
    var _strideCalibration: [Data_PbCalibrationValue] = []
    var _forwardAcceleration: [Float] = []
    var _forwardAccelerationOffline: [PbSensorOffline] = []
    var _movingTypeSamples: [PbMovingType] = []
    var _movingTypeOffline: [PbSensorOffline] = []
    var _leftPedalPowerSamples: [Data_PbPowerMeasurements] = []
    var _leftPedalPowerOffline: [PbSensorOffline] = []
    var _rightPedalPowerSamples: [Data_PbPowerMeasurements] = []
    var _rightPedalPowerOffline: [PbSensorOffline] = []
    var _leftPowerCalibration: [Data_PbCalibrationValue] = []
    var _rightPowerCalibration: [Data_PbCalibrationValue] = []
    var _rrSamples: Data_PbExerciseRRIntervals? = nil
    var _exerciseIntervalledSampleList: [Data_PbExerciseIntervalledSampleList] = []
    var _pauseTimes: [PbPauseTime] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _recordingInterval = source._recordingInterval
      _heartRateSamples = source._heartRateSamples
      _heartRateOffline = source._heartRateOffline
      _cadenceSamples = source._cadenceSamples
      _cadenceOffline = source._cadenceOffline
      _altitudeSamples = source._altitudeSamples
      _altitudeOffline = source._altitudeOffline
      _altitudeCalibration = source._altitudeCalibration
      _temperatureSamples = source._temperatureSamples
      _temperatureOffline = source._temperatureOffline
      _speedSamples = source._speedSamples
      _speedOffline = source._speedOffline
      _distanceSamples = source._distanceSamples
      _distanceOffline = source._distanceOffline
      _strideLengthSamples = source._strideLengthSamples
      _strideLengthOffline = source._strideLengthOffline
      _strideCalibration = source._strideCalibration
      _forwardAcceleration = source._forwardAcceleration
      _forwardAccelerationOffline = source._forwardAccelerationOffline
      _movingTypeSamples = source._movingTypeSamples
      _movingTypeOffline = source._movingTypeOffline
      _leftPedalPowerSamples = source._leftPedalPowerSamples
      _leftPedalPowerOffline = source._leftPedalPowerOffline
      _rightPedalPowerSamples = source._rightPedalPowerSamples
      _rightPedalPowerOffline = source._rightPedalPowerOffline
      _leftPowerCalibration = source._leftPowerCalibration
      _rightPowerCalibration = source._rightPowerCalibration
      _rrSamples = source._rrSamples
      _exerciseIntervalledSampleList = source._exerciseIntervalledSampleList
      _pauseTimes = source._pauseTimes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._recordingInterval == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._heartRateOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._cadenceOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._altitudeOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._altitudeCalibration) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._temperatureOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._speedOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._distanceOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._strideLengthOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._strideCalibration) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._forwardAccelerationOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._movingTypeOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._leftPedalPowerSamples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._leftPedalPowerOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rightPedalPowerSamples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rightPedalPowerOffline) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._leftPowerCalibration) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rightPowerCalibration) {return false}
      if let v = _storage._rrSamples, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._exerciseIntervalledSampleList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._pauseTimes) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._recordingInterval) }()
        case 2: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._heartRateSamples) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._heartRateOffline) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._cadenceSamples) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._cadenceOffline) }()
        case 6: try { try decoder.decodeRepeatedFloatField(value: &_storage._altitudeSamples) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._altitudeCalibration) }()
        case 8: try { try decoder.decodeRepeatedFloatField(value: &_storage._temperatureSamples) }()
        case 9: try { try decoder.decodeRepeatedFloatField(value: &_storage._speedSamples) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._speedOffline) }()
        case 11: try { try decoder.decodeRepeatedFloatField(value: &_storage._distanceSamples) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._distanceOffline) }()
        case 13: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._strideLengthSamples) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._strideLengthOffline) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._strideCalibration) }()
        case 16: try { try decoder.decodeRepeatedFloatField(value: &_storage._forwardAcceleration) }()
        case 17: try { try decoder.decodeRepeatedEnumField(value: &_storage._movingTypeSamples) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._altitudeOffline) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._temperatureOffline) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._forwardAccelerationOffline) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._movingTypeOffline) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._leftPedalPowerSamples) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._leftPedalPowerOffline) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._rightPedalPowerSamples) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._rightPedalPowerOffline) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._leftPowerCalibration) }()
        case 27: try { try decoder.decodeRepeatedMessageField(value: &_storage._rightPowerCalibration) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._rrSamples) }()
        case 29: try { try decoder.decodeRepeatedMessageField(value: &_storage._exerciseIntervalledSampleList) }()
        case 30: try { try decoder.decodeRepeatedMessageField(value: &_storage._pauseTimes) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._recordingInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._heartRateSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._heartRateSamples, fieldNumber: 2)
      }
      if !_storage._heartRateOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._heartRateOffline, fieldNumber: 3)
      }
      if !_storage._cadenceSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._cadenceSamples, fieldNumber: 4)
      }
      if !_storage._cadenceOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cadenceOffline, fieldNumber: 5)
      }
      if !_storage._altitudeSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._altitudeSamples, fieldNumber: 6)
      }
      if !_storage._altitudeCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._altitudeCalibration, fieldNumber: 7)
      }
      if !_storage._temperatureSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._temperatureSamples, fieldNumber: 8)
      }
      if !_storage._speedSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._speedSamples, fieldNumber: 9)
      }
      if !_storage._speedOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._speedOffline, fieldNumber: 10)
      }
      if !_storage._distanceSamples.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._distanceSamples, fieldNumber: 11)
      }
      if !_storage._distanceOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._distanceOffline, fieldNumber: 12)
      }
      if !_storage._strideLengthSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._strideLengthSamples, fieldNumber: 13)
      }
      if !_storage._strideLengthOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._strideLengthOffline, fieldNumber: 14)
      }
      if !_storage._strideCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._strideCalibration, fieldNumber: 15)
      }
      if !_storage._forwardAcceleration.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._forwardAcceleration, fieldNumber: 16)
      }
      if !_storage._movingTypeSamples.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._movingTypeSamples, fieldNumber: 17)
      }
      if !_storage._altitudeOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._altitudeOffline, fieldNumber: 18)
      }
      if !_storage._temperatureOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._temperatureOffline, fieldNumber: 19)
      }
      if !_storage._forwardAccelerationOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._forwardAccelerationOffline, fieldNumber: 20)
      }
      if !_storage._movingTypeOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._movingTypeOffline, fieldNumber: 21)
      }
      if !_storage._leftPedalPowerSamples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leftPedalPowerSamples, fieldNumber: 22)
      }
      if !_storage._leftPedalPowerOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leftPedalPowerOffline, fieldNumber: 23)
      }
      if !_storage._rightPedalPowerSamples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rightPedalPowerSamples, fieldNumber: 24)
      }
      if !_storage._rightPedalPowerOffline.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rightPedalPowerOffline, fieldNumber: 25)
      }
      if !_storage._leftPowerCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leftPowerCalibration, fieldNumber: 26)
      }
      if !_storage._rightPowerCalibration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rightPowerCalibration, fieldNumber: 27)
      }
      try { if let v = _storage._rrSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      if !_storage._exerciseIntervalledSampleList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._exerciseIntervalledSampleList, fieldNumber: 29)
      }
      if !_storage._pauseTimes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pauseTimes, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Data_PbExerciseSamples, rhs: Data_PbExerciseSamples) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._recordingInterval != rhs_storage._recordingInterval {return false}
        if _storage._heartRateSamples != rhs_storage._heartRateSamples {return false}
        if _storage._heartRateOffline != rhs_storage._heartRateOffline {return false}
        if _storage._cadenceSamples != rhs_storage._cadenceSamples {return false}
        if _storage._cadenceOffline != rhs_storage._cadenceOffline {return false}
        if _storage._altitudeSamples != rhs_storage._altitudeSamples {return false}
        if _storage._altitudeOffline != rhs_storage._altitudeOffline {return false}
        if _storage._altitudeCalibration != rhs_storage._altitudeCalibration {return false}
        if _storage._temperatureSamples != rhs_storage._temperatureSamples {return false}
        if _storage._temperatureOffline != rhs_storage._temperatureOffline {return false}
        if _storage._speedSamples != rhs_storage._speedSamples {return false}
        if _storage._speedOffline != rhs_storage._speedOffline {return false}
        if _storage._distanceSamples != rhs_storage._distanceSamples {return false}
        if _storage._distanceOffline != rhs_storage._distanceOffline {return false}
        if _storage._strideLengthSamples != rhs_storage._strideLengthSamples {return false}
        if _storage._strideLengthOffline != rhs_storage._strideLengthOffline {return false}
        if _storage._strideCalibration != rhs_storage._strideCalibration {return false}
        if _storage._forwardAcceleration != rhs_storage._forwardAcceleration {return false}
        if _storage._forwardAccelerationOffline != rhs_storage._forwardAccelerationOffline {return false}
        if _storage._movingTypeSamples != rhs_storage._movingTypeSamples {return false}
        if _storage._movingTypeOffline != rhs_storage._movingTypeOffline {return false}
        if _storage._leftPedalPowerSamples != rhs_storage._leftPedalPowerSamples {return false}
        if _storage._leftPedalPowerOffline != rhs_storage._leftPedalPowerOffline {return false}
        if _storage._rightPedalPowerSamples != rhs_storage._rightPedalPowerSamples {return false}
        if _storage._rightPedalPowerOffline != rhs_storage._rightPedalPowerOffline {return false}
        if _storage._leftPowerCalibration != rhs_storage._leftPowerCalibration {return false}
        if _storage._rightPowerCalibration != rhs_storage._rightPowerCalibration {return false}
        if _storage._rrSamples != rhs_storage._rrSamples {return false}
        if _storage._exerciseIntervalledSampleList != rhs_storage._exerciseIntervalledSampleList {return false}
        if _storage._pauseTimes != rhs_storage._pauseTimes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
