// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum PbDataType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not defined
  case undefined // = 0

  /// Inherited from parent field (for generics) 
  case inherited // = 1

  /// Reserved for enumerations
  case `enum` // = 2

  /// Milliseconds
  case millis // = 3

  /// Seconds
  case second // = 4

  /// Minutes
  case minute // = 5

  /// Hours
  case hour // = 6

  /// Hours
  case hours // = 7

  /// Day of month
  case day // = 8

  /// Month
  case month // = 9

  /// Year
  case year // = 10

  /// Kilograms
  case weight // = 11

  /// Centimeters
  case height // = 12

  /// ml/kg/min
  case vo2Max // = 13

  /// bpm
  case heartrate // = 20

  /// hr%
  case hrPercent // = 21

  /// hrr
  case hrReserve // = 22

  /// km/h
  case speed // = 23

  /// Rotations per minute (rpm)
  case cadence // = 24

  /// Meters
  case altitude // = 25

  /// Watts
  case power // = 26

  /// Percentage of left foot
  case powerLrb // = 27

  /// 0-100 ("Percentage")
  case powerPi // = 28

  /// Celsius
  case temperature // = 29

  /// Metabolic Equivalent of Task (MET)
  case activity // = 30

  /// Stride length while running (cm)
  case strideLength // = 31

  /// Climbing angle (%)
  case incline // = 32

  /// Descending angle (%)
  case decline // = 33

  /// Meters
  case distance // = 52

  /// Energy consumption (kcal), float.
  case energy // = 53

  /// Percentage
  case fatPercents // = 54

  /// Continuous ascent
  case ascent // = 55

  /// Continuous descent
  case descent // = 56

  /// Latitude
  case latitude // = 57

  /// Longitude
  case longitude // = 58

  /// Hertz
  case hertz // = 59

  /// 0-100 Percentage
  case percent // = 60

  /// Amount of activity cumulated during single day (METmin)
  case cumulatedActivityDay // = 61

  /// Running index result
  case runningIndex // = 62

  /// ms
  case rrInterval // = 63

  /// Orthostatic test: Z-index
  case zIndex // = 64

  /// Exercise target index
  case exerciseTargetIndex // = 65

  /// Time zone offset in minutes
  case timeZoneOffset // = 66

  /// Bike wheel size
  case wheelSize // = 67

  /// Fitness class [1 - 7] based on VO2max, age and gender
  case fitnessClass // = 68

  /// User 1d acceleration (m/s2)
  case acceleration // = 69

  /// Length of the crank in bike
  case crankLength // = 70

  /// General positive angle in degrees
  case angleDegree // = 71

  /// Force values (N)
  case newton // = 72

  /// FTP value in watts
  case functionalThresholdPower // = 73

  /// Energy consumption (kcal), integer.
  case calories // = 74

  /// Calibration offset calculated from two speed sources (km/h)
  case speedCalibrationOffset // = 75

  /// Week number
  case week // = 76

  /// Load of cardio activity (exercise or activity), float
  case cardioLoad // = 77

  /// MAP value in watts
  case maximumAerobicPower // = 78

  /// MAS value in km/h
  case maximumAerobicSpeed // = 79

  /// Muscle load of an exercise. Related to power measurement (kJ)
  case muscleLoad // = 80

  /// Perceived load of an exercise, float       
  case perceivedLoad // = 81

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .inherited
    case 2: self = .enum
    case 3: self = .millis
    case 4: self = .second
    case 5: self = .minute
    case 6: self = .hour
    case 7: self = .hours
    case 8: self = .day
    case 9: self = .month
    case 10: self = .year
    case 11: self = .weight
    case 12: self = .height
    case 13: self = .vo2Max
    case 20: self = .heartrate
    case 21: self = .hrPercent
    case 22: self = .hrReserve
    case 23: self = .speed
    case 24: self = .cadence
    case 25: self = .altitude
    case 26: self = .power
    case 27: self = .powerLrb
    case 28: self = .powerPi
    case 29: self = .temperature
    case 30: self = .activity
    case 31: self = .strideLength
    case 32: self = .incline
    case 33: self = .decline
    case 52: self = .distance
    case 53: self = .energy
    case 54: self = .fatPercents
    case 55: self = .ascent
    case 56: self = .descent
    case 57: self = .latitude
    case 58: self = .longitude
    case 59: self = .hertz
    case 60: self = .percent
    case 61: self = .cumulatedActivityDay
    case 62: self = .runningIndex
    case 63: self = .rrInterval
    case 64: self = .zIndex
    case 65: self = .exerciseTargetIndex
    case 66: self = .timeZoneOffset
    case 67: self = .wheelSize
    case 68: self = .fitnessClass
    case 69: self = .acceleration
    case 70: self = .crankLength
    case 71: self = .angleDegree
    case 72: self = .newton
    case 73: self = .functionalThresholdPower
    case 74: self = .calories
    case 75: self = .speedCalibrationOffset
    case 76: self = .week
    case 77: self = .cardioLoad
    case 78: self = .maximumAerobicPower
    case 79: self = .maximumAerobicSpeed
    case 80: self = .muscleLoad
    case 81: self = .perceivedLoad
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .inherited: return 1
    case .enum: return 2
    case .millis: return 3
    case .second: return 4
    case .minute: return 5
    case .hour: return 6
    case .hours: return 7
    case .day: return 8
    case .month: return 9
    case .year: return 10
    case .weight: return 11
    case .height: return 12
    case .vo2Max: return 13
    case .heartrate: return 20
    case .hrPercent: return 21
    case .hrReserve: return 22
    case .speed: return 23
    case .cadence: return 24
    case .altitude: return 25
    case .power: return 26
    case .powerLrb: return 27
    case .powerPi: return 28
    case .temperature: return 29
    case .activity: return 30
    case .strideLength: return 31
    case .incline: return 32
    case .decline: return 33
    case .distance: return 52
    case .energy: return 53
    case .fatPercents: return 54
    case .ascent: return 55
    case .descent: return 56
    case .latitude: return 57
    case .longitude: return 58
    case .hertz: return 59
    case .percent: return 60
    case .cumulatedActivityDay: return 61
    case .runningIndex: return 62
    case .rrInterval: return 63
    case .zIndex: return 64
    case .exerciseTargetIndex: return 65
    case .timeZoneOffset: return 66
    case .wheelSize: return 67
    case .fitnessClass: return 68
    case .acceleration: return 69
    case .crankLength: return 70
    case .angleDegree: return 71
    case .newton: return 72
    case .functionalThresholdPower: return 73
    case .calories: return 74
    case .speedCalibrationOffset: return 75
    case .week: return 76
    case .cardioLoad: return 77
    case .maximumAerobicPower: return 78
    case .maximumAerobicSpeed: return 79
    case .muscleLoad: return 80
    case .perceivedLoad: return 81
    }
  }

}

#if swift(>=4.2)

extension PbDataType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbHeartRateView: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case heartRateViewBpm // = 1
  case heartRateViewPercentsOfHrReserve // = 2
  case heartRateViewPercentsOfMaxHr // = 3

  public init() {
    self = .heartRateViewBpm
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .heartRateViewBpm
    case 2: self = .heartRateViewPercentsOfHrReserve
    case 3: self = .heartRateViewPercentsOfMaxHr
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .heartRateViewBpm: return 1
    case .heartRateViewPercentsOfHrReserve: return 2
    case .heartRateViewPercentsOfMaxHr: return 3
    }
  }

}

#if swift(>=4.2)

extension PbHeartRateView: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbUnitSystem: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case metric // = 1
  case imperial // = 2

  public init() {
    self = .metric
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .metric
    case 2: self = .imperial
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .metric: return 1
    case .imperial: return 2
    }
  }

}

#if swift(>=4.2)

extension PbUnitSystem: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbTimeSelection: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case time1 // = 1
  case time2 // = 2

  public init() {
    self = .time1
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .time1
    case 2: self = .time2
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .time1: return 1
    case .time2: return 2
    }
  }

}

#if swift(>=4.2)

extension PbTimeSelection: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbTimeFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case timeFormat24H // = 1
  case timeFormat12H // = 2

  public init() {
    self = .timeFormat24H
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .timeFormat24H
    case 2: self = .timeFormat12H
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .timeFormat24H: return 1
    case .timeFormat12H: return 2
    }
  }

}

#if swift(>=4.2)

extension PbTimeFormat: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbTimeFormatSeparator: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case timeFormatSeparatorDot // = 1
  case timeFormatSeparatorColon // = 2

  public init() {
    self = .timeFormatSeparatorDot
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .timeFormatSeparatorDot
    case 2: self = .timeFormatSeparatorColon
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .timeFormatSeparatorDot: return 1
    case .timeFormatSeparatorColon: return 2
    }
  }

}

#if swift(>=4.2)

extension PbTimeFormatSeparator: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbStartDayOfWeek: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case monday // = 1
  case saturday // = 2
  case sunday // = 3

  public init() {
    self = .monday
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .monday
    case 2: self = .saturday
    case 3: self = .sunday
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .monday: return 1
    case .saturday: return 2
    case .sunday: return 3
    }
  }

}

#if swift(>=4.2)

extension PbStartDayOfWeek: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbDateFormatSeparator: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case dot // = 1
  case slash // = 2
  case hyphen // = 3

  public init() {
    self = .dot
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .dot
    case 2: self = .slash
    case 3: self = .hyphen
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .dot: return 1
    case .slash: return 2
    case .hyphen: return 3
    }
  }

}

#if swift(>=4.2)

extension PbDateFormatSeparator: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbDateFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ddMmYyyy // = 1
  case mmDdYyyy // = 2
  case yyyyMmDd // = 3

  public init() {
    self = .ddMmYyyy
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .ddMmYyyy
    case 2: self = .mmDdYyyy
    case 3: self = .yyyyMmDd
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .ddMmYyyy: return 1
    case .mmDdYyyy: return 2
    case .yyyyMmDd: return 3
    }
  }

}

#if swift(>=4.2)

extension PbDateFormat: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// types of data that are suitable for bluetooth device features
/// NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
/// of the enum
public enum PbFeatureType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case featureTypeHeartRate // = 1
  case featureTypeRrInterval // = 2
  case featureTypeSpeed // = 3
  case featureTypeDistance // = 4
  case featureTypeBikeCadence // = 5
  case featureTypeBikePower // = 6
  case featureTypeGpsLocation // = 7
  case featureTypeRunningCadence // = 8
  case featureTypePressTemperature // = 9
  case featureTypeAltitude // = 10
  case featureTypeSteps // = 11
  case featureTypeActivity // = 12
  case featureTypeStrideLength // = 13
  case featureTypeRscMovingType // = 14
  case featureTypeJumpHeigth // = 15
  case featureTypeCompassHeading // = 16
  case featureTypeGpsSpeed // = 17
  case featureTypeGpsDistance // = 18
  case featureTypeGpsAltitude // = 19
  case featureTypeBikeWheelRevolution // = 20
  case featureTypeBikeCrankRevolution // = 21
  case featureTypeAsSpeed // = 22
  case featureTypeAsCadence // = 23
  case featureTypeAsDistance // = 24
  case featureTypeAsSwrState // = 25
  case featureTypeBatteryLevel // = 26
  case featureTypeFileTransfer // = 27
  case featureTypePushNotifications // = 28
  case featureTypeWeightScale // = 29
  case featureTypeRemoteButtons // = 30
  case featureTypeGopro // = 31
  case featureTypePpInterval // = 32
  case featureTypeMediaControl // = 33
  case featureTypeMobileGps // = 34

  public init() {
    self = .featureTypeHeartRate
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .featureTypeHeartRate
    case 2: self = .featureTypeRrInterval
    case 3: self = .featureTypeSpeed
    case 4: self = .featureTypeDistance
    case 5: self = .featureTypeBikeCadence
    case 6: self = .featureTypeBikePower
    case 7: self = .featureTypeGpsLocation
    case 8: self = .featureTypeRunningCadence
    case 9: self = .featureTypePressTemperature
    case 10: self = .featureTypeAltitude
    case 11: self = .featureTypeSteps
    case 12: self = .featureTypeActivity
    case 13: self = .featureTypeStrideLength
    case 14: self = .featureTypeRscMovingType
    case 15: self = .featureTypeJumpHeigth
    case 16: self = .featureTypeCompassHeading
    case 17: self = .featureTypeGpsSpeed
    case 18: self = .featureTypeGpsDistance
    case 19: self = .featureTypeGpsAltitude
    case 20: self = .featureTypeBikeWheelRevolution
    case 21: self = .featureTypeBikeCrankRevolution
    case 22: self = .featureTypeAsSpeed
    case 23: self = .featureTypeAsCadence
    case 24: self = .featureTypeAsDistance
    case 25: self = .featureTypeAsSwrState
    case 26: self = .featureTypeBatteryLevel
    case 27: self = .featureTypeFileTransfer
    case 28: self = .featureTypePushNotifications
    case 29: self = .featureTypeWeightScale
    case 30: self = .featureTypeRemoteButtons
    case 31: self = .featureTypeGopro
    case 32: self = .featureTypePpInterval
    case 33: self = .featureTypeMediaControl
    case 34: self = .featureTypeMobileGps
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .featureTypeHeartRate: return 1
    case .featureTypeRrInterval: return 2
    case .featureTypeSpeed: return 3
    case .featureTypeDistance: return 4
    case .featureTypeBikeCadence: return 5
    case .featureTypeBikePower: return 6
    case .featureTypeGpsLocation: return 7
    case .featureTypeRunningCadence: return 8
    case .featureTypePressTemperature: return 9
    case .featureTypeAltitude: return 10
    case .featureTypeSteps: return 11
    case .featureTypeActivity: return 12
    case .featureTypeStrideLength: return 13
    case .featureTypeRscMovingType: return 14
    case .featureTypeJumpHeigth: return 15
    case .featureTypeCompassHeading: return 16
    case .featureTypeGpsSpeed: return 17
    case .featureTypeGpsDistance: return 18
    case .featureTypeGpsAltitude: return 19
    case .featureTypeBikeWheelRevolution: return 20
    case .featureTypeBikeCrankRevolution: return 21
    case .featureTypeAsSpeed: return 22
    case .featureTypeAsCadence: return 23
    case .featureTypeAsDistance: return 24
    case .featureTypeAsSwrState: return 25
    case .featureTypeBatteryLevel: return 26
    case .featureTypeFileTransfer: return 27
    case .featureTypePushNotifications: return 28
    case .featureTypeWeightScale: return 29
    case .featureTypeRemoteButtons: return 30
    case .featureTypeGopro: return 31
    case .featureTypePpInterval: return 32
    case .featureTypeMediaControl: return 33
    case .featureTypeMobileGps: return 34
    }
  }

}

#if swift(>=4.2)

extension PbFeatureType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbMovingType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case walking // = 0
  case running // = 1
  case standing // = 2

  public init() {
    self = .walking
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .walking
    case 1: self = .running
    case 2: self = .standing
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .walking: return 0
    case .running: return 1
    case .standing: return 2
    }
  }

}

#if swift(>=4.2)

extension PbMovingType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbOperationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case multiply // = 1
  case sum // = 2

  public init() {
    self = .multiply
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .multiply
    case 2: self = .sum
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .multiply: return 1
    case .sum: return 2
    }
  }

}

#if swift(>=4.2)

extension PbOperationType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbExerciseFeedback: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case feedbackNone // = 1
  case feedback1 // = 2
  case feedback2 // = 3
  case feedback3 // = 4
  case feedback4 // = 5
  case feedback5 // = 6
  case feedback6 // = 7
  case feedback7 // = 8
  case feedback8 // = 9
  case feedback9 // = 10
  case feedback10 // = 11
  case feedback11 // = 12
  case feedback12 // = 13
  case feedback13 // = 14
  case feedback14 // = 15
  case feedback15 // = 16
  case feedback16 // = 17
  case feedback17 // = 18

  public init() {
    self = .feedbackNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .feedbackNone
    case 2: self = .feedback1
    case 3: self = .feedback2
    case 4: self = .feedback3
    case 5: self = .feedback4
    case 6: self = .feedback5
    case 7: self = .feedback6
    case 8: self = .feedback7
    case 9: self = .feedback8
    case 10: self = .feedback9
    case 11: self = .feedback10
    case 12: self = .feedback11
    case 13: self = .feedback12
    case 14: self = .feedback13
    case 15: self = .feedback14
    case 16: self = .feedback15
    case 17: self = .feedback16
    case 18: self = .feedback17
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .feedbackNone: return 1
    case .feedback1: return 2
    case .feedback2: return 3
    case .feedback3: return 4
    case .feedback4: return 5
    case .feedback5: return 6
    case .feedback6: return 7
    case .feedback7: return 8
    case .feedback8: return 9
    case .feedback9: return 10
    case .feedback10: return 11
    case .feedback11: return 12
    case .feedback12: return 13
    case .feedback13: return 14
    case .feedback14: return 15
    case .feedback15: return 16
    case .feedback16: return 17
    case .feedback17: return 18
    }
  }

}

#if swift(>=4.2)

extension PbExerciseFeedback: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbHeartRateZoneSettingSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// HRmax based
  case heartRateZoneSettingSourceDefault // = 0

  /// An/aerobic threshold based
  case heartRateZoneSettingSourceThreshold // = 1

  /// User's freely selected
  case heartRateZoneSettingSourceFree // = 2

  public init() {
    self = .heartRateZoneSettingSourceDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .heartRateZoneSettingSourceDefault
    case 1: self = .heartRateZoneSettingSourceThreshold
    case 2: self = .heartRateZoneSettingSourceFree
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .heartRateZoneSettingSourceDefault: return 0
    case .heartRateZoneSettingSourceThreshold: return 1
    case .heartRateZoneSettingSourceFree: return 2
    }
  }

}

#if swift(>=4.2)

extension PbHeartRateZoneSettingSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbPowerZoneSettingSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// See PbPowerZoneCalculationMethod
  case powerZoneSettingSourceDefault // = 0

  /// User's freely selected
  case powerZoneSettingSourceFree // = 1

  public init() {
    self = .powerZoneSettingSourceDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .powerZoneSettingSourceDefault
    case 1: self = .powerZoneSettingSourceFree
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .powerZoneSettingSourceDefault: return 0
    case .powerZoneSettingSourceFree: return 1
    }
  }

}

#if swift(>=4.2)

extension PbPowerZoneSettingSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbSpeedZoneSettingSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// See PbSpeedZoneCalculationMethod
  case speedZoneSettingSourceDefault // = 0

  /// User's freely selected
  case speedZoneSettingSourceFree // = 1

  public init() {
    self = .speedZoneSettingSourceDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .speedZoneSettingSourceDefault
    case 1: self = .speedZoneSettingSourceFree
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .speedZoneSettingSourceDefault: return 0
    case .speedZoneSettingSourceFree: return 1
    }
  }

}

#if swift(>=4.2)

extension PbSpeedZoneSettingSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The method used to calculate power zones when source is POWER_ZONE_SETTING_SOURCE_DEFAULT
public enum PbPowerZoneCalculationMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Fallback value for future-proofing
  case powerZoneCalculationMethodUnknown // = 0

  /// Power zones are calculated based on user's Functional Threshold Power (FTP), or estimated FTP if user has not explicitly set her FTP
  case powerZoneCalculationMethodFtpBased // = 1

  /// Power zones are calculated based on user's Maximum Aerobic Power (MAP), or estimated MAP if user has not explicitly set her MAP
  case powerZoneCalculationMethodMapBased // = 2

  public init() {
    self = .powerZoneCalculationMethodUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .powerZoneCalculationMethodUnknown
    case 1: self = .powerZoneCalculationMethodFtpBased
    case 2: self = .powerZoneCalculationMethodMapBased
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .powerZoneCalculationMethodUnknown: return 0
    case .powerZoneCalculationMethodFtpBased: return 1
    case .powerZoneCalculationMethodMapBased: return 2
    }
  }

}

#if swift(>=4.2)

extension PbPowerZoneCalculationMethod: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The method used to calculate speed zones when source is SPEED_ZONE_SETTING_SOURCE_DEFAULT
public enum PbSpeedZoneCalculationMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Fallback value for future-proofing
  case speedZoneCalculationMethodUnknown // = 0

  /// Speed zones are "calculated" using the legacy method, which is sport-specific zone limits pre-defined by Polar
  case speedZoneCalculationMethodSportSpecificPredefined // = 1

  /// Speed zones are calculated based on user's Maximum Aerobic Speed (MAS), or estimated MAS if user has not explicitly set her MAS
  case speedZoneCalculationMethodMasBased // = 2

  public init() {
    self = .speedZoneCalculationMethodUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .speedZoneCalculationMethodUnknown
    case 1: self = .speedZoneCalculationMethodSportSpecificPredefined
    case 2: self = .speedZoneCalculationMethodMasBased
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .speedZoneCalculationMethodUnknown: return 0
    case .speedZoneCalculationMethodSportSpecificPredefined: return 1
    case .speedZoneCalculationMethodMasBased: return 2
    }
  }

}

#if swift(>=4.2)

extension PbSpeedZoneCalculationMethod: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbMacType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case macTypePublic // = 0
  case macTypeStatic // = 1
  case macTypePrivateNonresolvable // = 2
  case macTypePrivateResolvable // = 3

  ///BT classic uses public address, but we use different type internally
  case macTypeBtClassic // = 4

  public init() {
    self = .macTypePublic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .macTypePublic
    case 1: self = .macTypeStatic
    case 2: self = .macTypePrivateNonresolvable
    case 3: self = .macTypePrivateResolvable
    case 4: self = .macTypeBtClassic
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .macTypePublic: return 0
    case .macTypeStatic: return 1
    case .macTypePrivateNonresolvable: return 2
    case .macTypePrivateResolvable: return 3
    case .macTypeBtClassic: return 4
    }
  }

}

#if swift(>=4.2)

extension PbMacType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbSwimmingStyle: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Other (not swimming)
  case other // = -1

  /// Between swimming styles 
  case turn // = 0

  /// Swimming style not definable but still swimming
  case otherSwimming // = 10

  /// Freestyle
  case freestyle // = 11

  /// Breaststroke
  case breaststroke // = 12

  /// Backstroke
  case backstroke // = 13

  /// Butterfly
  case butterfly // = 14

  /// Any drill type (eg. kick board drills)
  case drill // = 15

  public init() {
    self = .other
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .other
    case 0: self = .turn
    case 10: self = .otherSwimming
    case 11: self = .freestyle
    case 12: self = .breaststroke
    case 13: self = .backstroke
    case 14: self = .butterfly
    case 15: self = .drill
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .other: return -1
    case .turn: return 0
    case .otherSwimming: return 10
    case .freestyle: return 11
    case .breaststroke: return 12
    case .backstroke: return 13
    case .butterfly: return 14
    case .drill: return 15
    }
  }

}

#if swift(>=4.2)

extension PbSwimmingStyle: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbSwimmingPoolUnits: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Swimming has been exercised in meter sized pool
  case swimmingPoolMeters // = 0

  /// Swimming has been exercise in yards sized pool
  case swimmingPoolYards // = 1

  public init() {
    self = .swimmingPoolMeters
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .swimmingPoolMeters
    case 1: self = .swimmingPoolYards
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .swimmingPoolMeters: return 0
    case .swimmingPoolYards: return 1
    }
  }

}

#if swift(>=4.2)

extension PbSwimmingPoolUnits: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbExerciseTargetType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case exerciseTargetTypeFree // = 0
  case exerciseTargetTypeVolume // = 1
  case exerciseTargetTypePhased // = 2
  case exerciseTargetTypeRoute // = 3
  case exerciseTargetTypeSteadyRacePace // = 4
  case exerciseTargetTypeRouteRacePace // = 5
  case exerciseTargetTypeStravaSegment // = 6
  case exerciseTargetTypeStrengthTraining // = 7

  public init() {
    self = .exerciseTargetTypeFree
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .exerciseTargetTypeFree
    case 1: self = .exerciseTargetTypeVolume
    case 2: self = .exerciseTargetTypePhased
    case 3: self = .exerciseTargetTypeRoute
    case 4: self = .exerciseTargetTypeSteadyRacePace
    case 5: self = .exerciseTargetTypeRouteRacePace
    case 6: self = .exerciseTargetTypeStravaSegment
    case 7: self = .exerciseTargetTypeStrengthTraining
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .exerciseTargetTypeFree: return 0
    case .exerciseTargetTypeVolume: return 1
    case .exerciseTargetTypePhased: return 2
    case .exerciseTargetTypeRoute: return 3
    case .exerciseTargetTypeSteadyRacePace: return 4
    case .exerciseTargetTypeRouteRacePace: return 5
    case .exerciseTargetTypeStravaSegment: return 6
    case .exerciseTargetTypeStrengthTraining: return 7
    }
  }

}

#if swift(>=4.2)

extension PbExerciseTargetType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///Enums for transferring button state to/from device
public enum Buttons: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Guitar, Archer: up
  case buttonPlus // = 0

  ///Guitar, Archer: down
  case buttonMinus // = 1

  ///Guitar, Archer: start
  case buttonOk // = 2

  ///Guitar, Archer: light
  case buttonLight // = 3

  ///Guitar, Archer: back
  case buttonBack // = 4

  public init() {
    self = .buttonPlus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .buttonPlus
    case 1: self = .buttonMinus
    case 2: self = .buttonOk
    case 3: self = .buttonLight
    case 4: self = .buttonBack
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .buttonPlus: return 0
    case .buttonMinus: return 1
    case .buttonOk: return 2
    case .buttonLight: return 3
    case .buttonBack: return 4
    }
  }

}

#if swift(>=4.2)

extension Buttons: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum ButtonState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case buttonPressed // = 0
  case buttonReleased // = 1

  public init() {
    self = .buttonPressed
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .buttonPressed
    case 1: self = .buttonReleased
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .buttonPressed: return 0
    case .buttonReleased: return 1
    }
  }

}

#if swift(>=4.2)

extension ButtonState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
///Sample types
public enum PbSampleType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not defined
  case sampleTypeUndefined // = 0

  /// Heart rate, bpm 
  case sampleTypeHeartRate // = 1

  /// Cadence, Rotations per minute (rpm)
  case sampleTypeCadence // = 2

  /// Altitude, meters 
  case sampleTypeAltitude // = 3

  /// Calibration info for altitude: indicate start and stop indexes, used calibration value and operation type of calibration 
  case sampleTypeAltitudeCalibration // = 4

  /// Temperature, celcius
  case sampleTypeTemperature // = 5

  /// Speed, km/h
  case sampleTypeSpeed // = 6

  /// Distance, meters  
  case sampleTypeDistance // = 7

  /// Stride length while running, cm
  case sampleTypeStrideLength // = 8

  /// Calibration info for stride: indicate start and stop indexes, used calibration value and operation type of calibration 
  case sampleTypeStrideCalibration // = 9

  /// Forward acceleration, m/s^2
  case sampleTypeForwardAcceleration // = 10

  /// Moving type, walking running, standing 
  case sampleTypeMovingType // = 11

  /// Power info from left pedal
  case sampleTypeLeftPedalPower // = 12

  /// Power info from right pedal
  case sampleTypeRightPedalPower // = 13

  /// Calibration info for left power: indicate start and stop indexes, used calibration value and operation type of calibration 
  case sampleTypeLeftPedalPowerCalibration // = 14

  /// Calibration info for right power: indicate start and stop indexes, used calibration value and operation type of calibration
  case sampleTypeRightPedalPowerCalibration // = 15

  /// RR-interval, ms
  case sampleTypeRrInterval // = 16

  /// Acceleration based Mean Amplitude Deviation (MAD), mg
  case sampleTypeAccelerationMad // = 17

  public init() {
    self = .sampleTypeUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sampleTypeUndefined
    case 1: self = .sampleTypeHeartRate
    case 2: self = .sampleTypeCadence
    case 3: self = .sampleTypeAltitude
    case 4: self = .sampleTypeAltitudeCalibration
    case 5: self = .sampleTypeTemperature
    case 6: self = .sampleTypeSpeed
    case 7: self = .sampleTypeDistance
    case 8: self = .sampleTypeStrideLength
    case 9: self = .sampleTypeStrideCalibration
    case 10: self = .sampleTypeForwardAcceleration
    case 11: self = .sampleTypeMovingType
    case 12: self = .sampleTypeLeftPedalPower
    case 13: self = .sampleTypeRightPedalPower
    case 14: self = .sampleTypeLeftPedalPowerCalibration
    case 15: self = .sampleTypeRightPedalPowerCalibration
    case 16: self = .sampleTypeRrInterval
    case 17: self = .sampleTypeAccelerationMad
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .sampleTypeUndefined: return 0
    case .sampleTypeHeartRate: return 1
    case .sampleTypeCadence: return 2
    case .sampleTypeAltitude: return 3
    case .sampleTypeAltitudeCalibration: return 4
    case .sampleTypeTemperature: return 5
    case .sampleTypeSpeed: return 6
    case .sampleTypeDistance: return 7
    case .sampleTypeStrideLength: return 8
    case .sampleTypeStrideCalibration: return 9
    case .sampleTypeForwardAcceleration: return 10
    case .sampleTypeMovingType: return 11
    case .sampleTypeLeftPedalPower: return 12
    case .sampleTypeRightPedalPower: return 13
    case .sampleTypeLeftPedalPowerCalibration: return 14
    case .sampleTypeRightPedalPowerCalibration: return 15
    case .sampleTypeRrInterval: return 16
    case .sampleTypeAccelerationMad: return 17
    }
  }

}

#if swift(>=4.2)

extension PbSampleType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
///Sample source types
public enum PbSampleSourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not defined
  case sampleSourceTypeUndefined // = 0

  /// Sample has no source, i.e., sample is offline
  case sampleSourceTypeOffline // = 1

  /// Heart rate measurement based samples   
  case sampleSourceTypeHeartRate // = 2

  /// BLE heart rate measurement based samples  
  case sampleSourceTypeHeartRateBle // = 3

  /// 5 kHz heart rate measurement based samples  
  case sampleSourceTypeHeartRate5Khz // = 4

  /// Optical heart rate measurement based samples  
  case sampleSourceTypeHeartRateOptical // = 5

  /// GPS measurement based samples                          
  case sampleSourceTypeGps // = 6

  /// Stride measurement based samples
  case sampleSourceTypeStride // = 7

  /// Samples that are based on wrist metrics like inertial (accelometer etc.) measurements 
  case sampleSourceTypeWristMetrics // = 8

  /// Samples that are based on chest metrics like inertial (accelometer etc.) measurements 
  case sampleSourceTypeChestMetrics // = 9

  /// Bike pedal measurement based samples 
  case sampleSourceTypeBikePedal // = 10

  /// Bike wheel measurement based samples 
  case sampleSourceTypeBikeWheel // = 11

  /// Bike crank measurement based samples 
  case sampleSourceTypeBikeCrank // = 12

  /// Samples that are combined from chest metrics and gps measurements 
  case sampleSourceTypeCombinedChestMetricsAndGps // = 13

  /// Samples that are based on upper back metrics like inertial (accelometer etc.) measurements 
  case sampleSourceTypeUpperBackMetrics // = 14

  /// Samples that are combined from upper back metrics and gps measurements 
  case sampleSourceTypeCombinedUpperBackMetricsAndGps // = 15

  public init() {
    self = .sampleSourceTypeUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sampleSourceTypeUndefined
    case 1: self = .sampleSourceTypeOffline
    case 2: self = .sampleSourceTypeHeartRate
    case 3: self = .sampleSourceTypeHeartRateBle
    case 4: self = .sampleSourceTypeHeartRate5Khz
    case 5: self = .sampleSourceTypeHeartRateOptical
    case 6: self = .sampleSourceTypeGps
    case 7: self = .sampleSourceTypeStride
    case 8: self = .sampleSourceTypeWristMetrics
    case 9: self = .sampleSourceTypeChestMetrics
    case 10: self = .sampleSourceTypeBikePedal
    case 11: self = .sampleSourceTypeBikeWheel
    case 12: self = .sampleSourceTypeBikeCrank
    case 13: self = .sampleSourceTypeCombinedChestMetricsAndGps
    case 14: self = .sampleSourceTypeUpperBackMetrics
    case 15: self = .sampleSourceTypeCombinedUpperBackMetricsAndGps
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .sampleSourceTypeUndefined: return 0
    case .sampleSourceTypeOffline: return 1
    case .sampleSourceTypeHeartRate: return 2
    case .sampleSourceTypeHeartRateBle: return 3
    case .sampleSourceTypeHeartRate5Khz: return 4
    case .sampleSourceTypeHeartRateOptical: return 5
    case .sampleSourceTypeGps: return 6
    case .sampleSourceTypeStride: return 7
    case .sampleSourceTypeWristMetrics: return 8
    case .sampleSourceTypeChestMetrics: return 9
    case .sampleSourceTypeBikePedal: return 10
    case .sampleSourceTypeBikeWheel: return 11
    case .sampleSourceTypeBikeCrank: return 12
    case .sampleSourceTypeCombinedChestMetricsAndGps: return 13
    case .sampleSourceTypeUpperBackMetrics: return 14
    case .sampleSourceTypeCombinedUpperBackMetricsAndGps: return 15
    }
  }

}

#if swift(>=4.2)

extension PbSampleSourceType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Altitude recording setting values.
///  NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
///  of the enum 
public enum PbAltitudeSetting: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Off
  case altitudeOff // = 0

  /// On
  case altitudeOn // = 1

  public init() {
    self = .altitudeOff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .altitudeOff
    case 1: self = .altitudeOn
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .altitudeOff: return 0
    case .altitudeOn: return 1
    }
  }

}

#if swift(>=4.2)

extension PbAltitudeSetting: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// GPS recording setting values.
///  NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
///  of the enum 
public enum PbGPSSetting: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Off
  case gpsOff // = 0

  /// On, normal, 1 sec rec rate
  case gpsOnNormal // = 1

  /// On, long, 60 sec rec rate
  case gpsOnLong // = 2

  /// On, 10 Hz, 0.1 sec rec rate
  case gpsOn10Hz // = 3

  /// On, medium, 30 sec rec rate  
  case gpsOnMedium // = 4

  public init() {
    self = .gpsOff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gpsOff
    case 1: self = .gpsOnNormal
    case 2: self = .gpsOnLong
    case 3: self = .gpsOn10Hz
    case 4: self = .gpsOnMedium
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .gpsOff: return 0
    case .gpsOnNormal: return 1
    case .gpsOnLong: return 2
    case .gpsOn10Hz: return 3
    case .gpsOnMedium: return 4
    }
  }

}

#if swift(>=4.2)

extension PbGPSSetting: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbHeartTouch: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case heartTouchOff // = 1
  case heartTouchActivateBacklight // = 2
  case heartTouchShowPreviousLap // = 3
  case heartTouchShowTimeOfDay // = 4

  public init() {
    self = .heartTouchOff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .heartTouchOff
    case 2: self = .heartTouchActivateBacklight
    case 3: self = .heartTouchShowPreviousLap
    case 4: self = .heartTouchShowTimeOfDay
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .heartTouchOff: return 1
    case .heartTouchActivateBacklight: return 2
    case .heartTouchShowPreviousLap: return 3
    case .heartTouchShowTimeOfDay: return 4
    }
  }

}

#if swift(>=4.2)

extension PbHeartTouch: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbTapButtonAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case tapButtonOff // = 1
  case tapButtonTakeLap // = 2
  case tapButtonChangeTrainingView // = 3
  case tapButtonActivateBacklight // = 4

  public init() {
    self = .tapButtonOff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .tapButtonOff
    case 2: self = .tapButtonTakeLap
    case 3: self = .tapButtonChangeTrainingView
    case 4: self = .tapButtonActivateBacklight
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .tapButtonOff: return 1
    case .tapButtonTakeLap: return 2
    case .tapButtonChangeTrainingView: return 3
    case .tapButtonActivateBacklight: return 4
    }
  }

}

#if swift(>=4.2)

extension PbTapButtonAction: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Obsolete, do not extend with new values
public enum PbHandedness: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case wuInLeftHand // = 1
  case wuInRightHand // = 2
  case wuInNecklace // = 3

  public init() {
    self = .wuInLeftHand
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .wuInLeftHand
    case 2: self = .wuInRightHand
    case 3: self = .wuInNecklace
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .wuInLeftHand: return 1
    case .wuInRightHand: return 2
    case .wuInNecklace: return 3
    }
  }

}

#if swift(>=4.2)

extension PbHandedness: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbDeviceLocation: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case deviceLocationUndefined // = 0
  case deviceLocationOther // = 1
  case deviceLocationWristLeft // = 2
  case deviceLocationWristRight // = 3
  case deviceLocationNecklace // = 4
  case deviceLocationChest // = 5
  case deviceLocationUpperBack // = 6
  case deviceLocationFootLeft // = 7
  case deviceLocationFootRight // = 8
  case deviceLocationLowerArmLeft // = 9
  case deviceLocationLowerArmRight // = 10
  case deviceLocationUpperArmLeft // = 11
  case deviceLocationUpperArmRight // = 12
  case deviceLocationBikeMount // = 13

  public init() {
    self = .deviceLocationUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deviceLocationUndefined
    case 1: self = .deviceLocationOther
    case 2: self = .deviceLocationWristLeft
    case 3: self = .deviceLocationWristRight
    case 4: self = .deviceLocationNecklace
    case 5: self = .deviceLocationChest
    case 6: self = .deviceLocationUpperBack
    case 7: self = .deviceLocationFootLeft
    case 8: self = .deviceLocationFootRight
    case 9: self = .deviceLocationLowerArmLeft
    case 10: self = .deviceLocationLowerArmRight
    case 11: self = .deviceLocationUpperArmLeft
    case 12: self = .deviceLocationUpperArmRight
    case 13: self = .deviceLocationBikeMount
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .deviceLocationUndefined: return 0
    case .deviceLocationOther: return 1
    case .deviceLocationWristLeft: return 2
    case .deviceLocationWristRight: return 3
    case .deviceLocationNecklace: return 4
    case .deviceLocationChest: return 5
    case .deviceLocationUpperBack: return 6
    case .deviceLocationFootLeft: return 7
    case .deviceLocationFootRight: return 8
    case .deviceLocationLowerArmLeft: return 9
    case .deviceLocationLowerArmRight: return 10
    case .deviceLocationUpperArmLeft: return 11
    case .deviceLocationUpperArmRight: return 12
    case .deviceLocationBikeMount: return 13
    }
  }

}

#if swift(>=4.2)

extension PbDeviceLocation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
///Session RPE (Rating Perceived Exertion) on a scale 1-10 (adopted Borg's scale).
///Describes how demanding the whole exercise was. Only one rating for multisport.
///NOTE! Naming of the enums may differ from respective UI texts (e.g. RPE_EXTREME may be shown as "Maximum").
public enum PbSessionRPE: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Very easy
  case rpeNone // = 1
  case rpeEasy // = 2
  case rpeLight // = 3
  case rpeFairlyBrisk // = 4
  case rpeBrisk // = 5
  case rpeModerate // = 6
  case rpeFairlyHard // = 7
  case rpeHard // = 8
  case rpeExhausting // = 9
  case rpeExtreme // = 10

  public init() {
    self = .rpeNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .rpeNone
    case 2: self = .rpeEasy
    case 3: self = .rpeLight
    case 4: self = .rpeFairlyBrisk
    case 5: self = .rpeBrisk
    case 6: self = .rpeModerate
    case 7: self = .rpeFairlyHard
    case 8: self = .rpeHard
    case 9: self = .rpeExhausting
    case 10: self = .rpeExtreme
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .rpeNone: return 1
    case .rpeEasy: return 2
    case .rpeLight: return 3
    case .rpeFairlyBrisk: return 4
    case .rpeBrisk: return 5
    case .rpeModerate: return 6
    case .rpeFairlyHard: return 7
    case .rpeHard: return 8
    case .rpeExhausting: return 9
    case .rpeExtreme: return 10
    }
  }

}

#if swift(>=4.2)

extension PbSessionRPE: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbMuscleSoreness: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case msUndefined // = -1
  case msNone // = 0
  case msSome // = 1
  case msMuch // = 2

  public init() {
    self = .msUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .msUndefined
    case 0: self = .msNone
    case 1: self = .msSome
    case 2: self = .msMuch
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .msUndefined: return -1
    case .msNone: return 0
    case .msSome: return 1
    case .msMuch: return 2
    }
  }

}

#if swift(>=4.2)

extension PbMuscleSoreness: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbOverallFatigue: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ofUndefined // = -1
  case ofNormal // = 0
  case ofALittle // = 1
  case ofMuch // = 2

  public init() {
    self = .ofUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .ofUndefined
    case 0: self = .ofNormal
    case 1: self = .ofALittle
    case 2: self = .ofMuch
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .ofUndefined: return -1
    case .ofNormal: return 0
    case .ofALittle: return 1
    case .ofMuch: return 2
    }
  }

}

#if swift(>=4.2)

extension PbOverallFatigue: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbSleepUserRating: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case pbSleptUndefined // = -1
  case pbSleptPoorly // = 0
  case pbSleptSomewhatPoorly // = 1
  case pbSleptNeitherPoorlyNorWell // = 2
  case pbSleptSomewhatWell // = 3
  case pbSleptWell // = 4

  public init() {
    self = .pbSleptUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .pbSleptUndefined
    case 0: self = .pbSleptPoorly
    case 1: self = .pbSleptSomewhatPoorly
    case 2: self = .pbSleptNeitherPoorlyNorWell
    case 3: self = .pbSleptSomewhatWell
    case 4: self = .pbSleptWell
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .pbSleptUndefined: return -1
    case .pbSleptPoorly: return 0
    case .pbSleptSomewhatPoorly: return 1
    case .pbSleptNeitherPoorlyNorWell: return 2
    case .pbSleptSomewhatWell: return 3
    case .pbSleptWell: return 4
    }
  }

}

#if swift(>=4.2)

extension PbSleepUserRating: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbDailyBalanceFeedback: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case dbNotCalculated // = -1
  case dbSick // = 0
  case dbFatigueTryToReduceTrainingLoadInjured // = 1
  case dbFatigueTryToReduceTrainingLoad // = 2
  case dbLimitedTrainingResponseOtherInjured // = 3
  case dbLimitedTrainingResponseOther // = 4
  case dbRespondingWellCanContinueIfInjuryAllows // = 5
  case dbRespondingWellCanContinue // = 6
  case dbYouCouldDoMoreTrainingIfInjuryAllows // = 7
  case dbYouCouldDoMoreTraining // = 8
  case dbYouSeemToBeStrainedInjured // = 9
  case dbYouSeemToBeStrained // = 10

  public init() {
    self = .dbNotCalculated
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .dbNotCalculated
    case 0: self = .dbSick
    case 1: self = .dbFatigueTryToReduceTrainingLoadInjured
    case 2: self = .dbFatigueTryToReduceTrainingLoad
    case 3: self = .dbLimitedTrainingResponseOtherInjured
    case 4: self = .dbLimitedTrainingResponseOther
    case 5: self = .dbRespondingWellCanContinueIfInjuryAllows
    case 6: self = .dbRespondingWellCanContinue
    case 7: self = .dbYouCouldDoMoreTrainingIfInjuryAllows
    case 8: self = .dbYouCouldDoMoreTraining
    case 9: self = .dbYouSeemToBeStrainedInjured
    case 10: self = .dbYouSeemToBeStrained
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .dbNotCalculated: return -1
    case .dbSick: return 0
    case .dbFatigueTryToReduceTrainingLoadInjured: return 1
    case .dbFatigueTryToReduceTrainingLoad: return 2
    case .dbLimitedTrainingResponseOtherInjured: return 3
    case .dbLimitedTrainingResponseOther: return 4
    case .dbRespondingWellCanContinueIfInjuryAllows: return 5
    case .dbRespondingWellCanContinue: return 6
    case .dbYouCouldDoMoreTrainingIfInjuryAllows: return 7
    case .dbYouCouldDoMoreTraining: return 8
    case .dbYouSeemToBeStrainedInjured: return 9
    case .dbYouSeemToBeStrained: return 10
    }
  }

}

#if swift(>=4.2)

extension PbDailyBalanceFeedback: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The definitions for readiness feedback: https://wiki.polar.grp/display/SYSFEA/Jump+Test
public enum PbReadinessForSpeedAndStrengthTraining: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case rsstNotCalculated // = -1
  case rsstA1RecoveredReadyForAllTraining // = 0
  case rsstA2RecoveredReadyForAllTrainingIfFeelingOkNightlyRechargeCompromised // = 1
  case rsstA3RecoveredReadyForAllTrainingIfFeelingOkPossiblyStressed // = 2
  case rsstA4RecoveredReadyForSpeedAndStrengthTraining // = 3
  case rsstB1RecoveredReadyForSpeedAndStrengthTrainingAndLightCardio // = 4
  case rsstB2RecoveredReadyForSpeedAndStrengthTrainingAndLightCardioPoorNightlyRecharge // = 5
  case rsstB3RecoveredReadyForSpeedAndStrengthTrainingAndLightCardioPoorCardioRecovery // = 6
  case rsstB4NotRecoveredNoLegTrainingOrIntensiveCardio // = 7
  case rsstB5NotRecoveredNoLegTrainingOrIntensiveCardioPoorNightlyRecharge // = 8
  case rsstC1NotRecoveredNoStrengthOrIntensiveCardio // = 9
  case rsstC2NotRecoveredNoStrengthOrIntensiveCardioPoorNightlyRecharge // = 10
  case rsstD1RecoveredButInjuryAndIllnessRiskCausedByCardioTraining // = 11
  case rsstD2NotRecoveredAndInjuryAndIllnessRiskCausedByCardioTraining // = 12

  public init() {
    self = .rsstNotCalculated
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .rsstNotCalculated
    case 0: self = .rsstA1RecoveredReadyForAllTraining
    case 1: self = .rsstA2RecoveredReadyForAllTrainingIfFeelingOkNightlyRechargeCompromised
    case 2: self = .rsstA3RecoveredReadyForAllTrainingIfFeelingOkPossiblyStressed
    case 3: self = .rsstA4RecoveredReadyForSpeedAndStrengthTraining
    case 4: self = .rsstB1RecoveredReadyForSpeedAndStrengthTrainingAndLightCardio
    case 5: self = .rsstB2RecoveredReadyForSpeedAndStrengthTrainingAndLightCardioPoorNightlyRecharge
    case 6: self = .rsstB3RecoveredReadyForSpeedAndStrengthTrainingAndLightCardioPoorCardioRecovery
    case 7: self = .rsstB4NotRecoveredNoLegTrainingOrIntensiveCardio
    case 8: self = .rsstB5NotRecoveredNoLegTrainingOrIntensiveCardioPoorNightlyRecharge
    case 9: self = .rsstC1NotRecoveredNoStrengthOrIntensiveCardio
    case 10: self = .rsstC2NotRecoveredNoStrengthOrIntensiveCardioPoorNightlyRecharge
    case 11: self = .rsstD1RecoveredButInjuryAndIllnessRiskCausedByCardioTraining
    case 12: self = .rsstD2NotRecoveredAndInjuryAndIllnessRiskCausedByCardioTraining
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .rsstNotCalculated: return -1
    case .rsstA1RecoveredReadyForAllTraining: return 0
    case .rsstA2RecoveredReadyForAllTrainingIfFeelingOkNightlyRechargeCompromised: return 1
    case .rsstA3RecoveredReadyForAllTrainingIfFeelingOkPossiblyStressed: return 2
    case .rsstA4RecoveredReadyForSpeedAndStrengthTraining: return 3
    case .rsstB1RecoveredReadyForSpeedAndStrengthTrainingAndLightCardio: return 4
    case .rsstB2RecoveredReadyForSpeedAndStrengthTrainingAndLightCardioPoorNightlyRecharge: return 5
    case .rsstB3RecoveredReadyForSpeedAndStrengthTrainingAndLightCardioPoorCardioRecovery: return 6
    case .rsstB4NotRecoveredNoLegTrainingOrIntensiveCardio: return 7
    case .rsstB5NotRecoveredNoLegTrainingOrIntensiveCardioPoorNightlyRecharge: return 8
    case .rsstC1NotRecoveredNoStrengthOrIntensiveCardio: return 9
    case .rsstC2NotRecoveredNoStrengthOrIntensiveCardioPoorNightlyRecharge: return 10
    case .rsstD1RecoveredButInjuryAndIllnessRiskCausedByCardioTraining: return 11
    case .rsstD2NotRecoveredAndInjuryAndIllnessRiskCausedByCardioTraining: return 12
    }
  }

}

#if swift(>=4.2)

extension PbReadinessForSpeedAndStrengthTraining: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbStrengthTrainingRoundRepetitionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Currently NORMAL is the only type. Other types, such as AMRAP, can/will be added later.
  /// See also: https://wiki.polar.grp/display/SYSFEA/Strength+Training+Logical+Domain+Model
  case normal // = 0

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    }
  }

}

#if swift(>=4.2)

extension PbStrengthTrainingRoundRepetitionType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum PbStrengthTrainingWorkoutPhase: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Round with workout sets
  case work // = 0

  /// Round prepares exerciser for upcoming work rounds. Typically the first round of a training session.
  case warmUp // = 1

  /// Round for cooling down. Typically the last round of a training session.
  case coolDown // = 2

  public init() {
    self = .work
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .work
    case 1: self = .warmUp
    case 2: self = .coolDown
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .work: return 0
    case .warmUp: return 1
    case .coolDown: return 2
    }
  }

}

#if swift(>=4.2)

extension PbStrengthTrainingWorkoutPhase: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct PbRangeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ALL_TC
  public var minValue: Int32 {
    get {return _minValue ?? 0}
    set {_minValue = newValue}
  }
  /// Returns true if `minValue` has been explicitly set.
  public var hasMinValue: Bool {return self._minValue != nil}
  /// Clears the value of `minValue`. Subsequent reads from it will return its default value.
  public mutating func clearMinValue() {self._minValue = nil}

  /// ALL_TC
  public var maxValue: Int32 {
    get {return _maxValue ?? 0}
    set {_maxValue = newValue}
  }
  /// Returns true if `maxValue` has been explicitly set.
  public var hasMaxValue: Bool {return self._maxValue != nil}
  /// Clears the value of `maxValue`. Subsequent reads from it will return its default value.
  public mutating func clearMaxValue() {self._maxValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _minValue: Int32? = nil
  fileprivate var _maxValue: Int32? = nil
}

public struct PbDate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var year: UInt32 {
    get {return _year ?? 0}
    set {_year = newValue}
  }
  /// Returns true if `year` has been explicitly set.
  public var hasYear: Bool {return self._year != nil}
  /// Clears the value of `year`. Subsequent reads from it will return its default value.
  public mutating func clearYear() {self._year = nil}

  public var month: UInt32 {
    get {return _month ?? 0}
    set {_month = newValue}
  }
  /// Returns true if `month` has been explicitly set.
  public var hasMonth: Bool {return self._month != nil}
  /// Clears the value of `month`. Subsequent reads from it will return its default value.
  public mutating func clearMonth() {self._month = nil}

  public var day: UInt32 {
    get {return _day ?? 0}
    set {_day = newValue}
  }
  /// Returns true if `day` has been explicitly set.
  public var hasDay: Bool {return self._day != nil}
  /// Clears the value of `day`. Subsequent reads from it will return its default value.
  public mutating func clearDay() {self._day = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _year: UInt32? = nil
  fileprivate var _month: UInt32? = nil
  fileprivate var _day: UInt32? = nil
}

public struct PbTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hour: UInt32 {
    get {return _hour ?? 0}
    set {_hour = newValue}
  }
  /// Returns true if `hour` has been explicitly set.
  public var hasHour: Bool {return self._hour != nil}
  /// Clears the value of `hour`. Subsequent reads from it will return its default value.
  public mutating func clearHour() {self._hour = nil}

  public var minute: UInt32 {
    get {return _minute ?? 0}
    set {_minute = newValue}
  }
  /// Returns true if `minute` has been explicitly set.
  public var hasMinute: Bool {return self._minute != nil}
  /// Clears the value of `minute`. Subsequent reads from it will return its default value.
  public mutating func clearMinute() {self._minute = nil}

  public var seconds: UInt32 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  public var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  public mutating func clearSeconds() {self._seconds = nil}

  /// ALL_TC
  public var millis: UInt32 {
    get {return _millis ?? 0}
    set {_millis = newValue}
  }
  /// Returns true if `millis` has been explicitly set.
  public var hasMillis: Bool {return self._millis != nil}
  /// Clears the value of `millis`. Subsequent reads from it will return its default value.
  public mutating func clearMillis() {self._millis = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hour: UInt32? = nil
  fileprivate var _minute: UInt32? = nil
  fileprivate var _seconds: UInt32? = nil
  fileprivate var _millis: UInt32? = nil
}

public struct PbSystemDateTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///
  ///The flag defines if the date & time combination originated
  ///from a trusted time source, such as PPT.com servers, GPS satelites,
  ///GPRS network, atomic clocks etc. 
  ///
  ///If the trusted flag is "false"
  ///the date time originated from untrusted source such as "set by user manually"
  ///or not set at all (some default value).
  ///
  ///For more information about "trusted time", please see SAGRFC27:
  ///(https://swa.polar.fi/sag/wiki/SAGRFC/SAGRFC27)
  public var trusted: Bool {
    get {return _trusted ?? false}
    set {_trusted = newValue}
  }
  /// Returns true if `trusted` has been explicitly set.
  public var hasTrusted: Bool {return self._trusted != nil}
  /// Clears the value of `trusted`. Subsequent reads from it will return its default value.
  public mutating func clearTrusted() {self._trusted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _trusted: Bool? = nil
}

public struct PbLocalDateTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// For binary compatibility with PbSystemDateTime.
  public var obsoleteTrusted: Bool {
    get {return _obsoleteTrusted ?? false}
    set {_obsoleteTrusted = newValue}
  }
  /// Returns true if `obsoleteTrusted` has been explicitly set.
  public var hasObsoleteTrusted: Bool {return self._obsoleteTrusted != nil}
  /// Clears the value of `obsoleteTrusted`. Subsequent reads from it will return its default value.
  public mutating func clearObsoleteTrusted() {self._obsoleteTrusted = nil}

  /// Time zone offset
  /// Range [-720 - 840] minutes
  public var timeZoneOffset: Int32 {
    get {return _timeZoneOffset ?? 0}
    set {_timeZoneOffset = newValue}
  }
  /// Returns true if `timeZoneOffset` has been explicitly set.
  public var hasTimeZoneOffset: Bool {return self._timeZoneOffset != nil}
  /// Clears the value of `timeZoneOffset`. Subsequent reads from it will return its default value.
  public mutating func clearTimeZoneOffset() {self._timeZoneOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _obsoleteTrusted: Bool? = nil
  fileprivate var _timeZoneOffset: Int32? = nil
}

public struct PbLocalDateTimeRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startTime: PbLocalDateTime {
    get {return _storage._startTime ?? PbLocalDateTime()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  public var endTime: PbLocalDateTime {
    get {return _storage._endTime ?? PbLocalDateTime()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PbDuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ALL_TC
  public var hours: UInt32 {
    get {return _hours ?? 0}
    set {_hours = newValue}
  }
  /// Returns true if `hours` has been explicitly set.
  public var hasHours: Bool {return self._hours != nil}
  /// Clears the value of `hours`. Subsequent reads from it will return its default value.
  public mutating func clearHours() {self._hours = nil}

  /// ALL_TC
  public var minutes: UInt32 {
    get {return _minutes ?? 0}
    set {_minutes = newValue}
  }
  /// Returns true if `minutes` has been explicitly set.
  public var hasMinutes: Bool {return self._minutes != nil}
  /// Clears the value of `minutes`. Subsequent reads from it will return its default value.
  public mutating func clearMinutes() {self._minutes = nil}

  /// ALL_TC
  public var seconds: UInt32 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  public var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  public mutating func clearSeconds() {self._seconds = nil}

  /// ALL_TC
  public var millis: UInt32 {
    get {return _millis ?? 0}
    set {_millis = newValue}
  }
  /// Returns true if `millis` has been explicitly set.
  public var hasMillis: Bool {return self._millis != nil}
  /// Clears the value of `millis`. Subsequent reads from it will return its default value.
  public mutating func clearMillis() {self._millis = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hours: UInt32? = nil
  fileprivate var _minutes: UInt32? = nil
  fileprivate var _seconds: UInt32? = nil
  fileprivate var _millis: UInt32? = nil
}

public struct PbLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ALL_TC
  public var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  public var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  public mutating func clearLatitude() {self._latitude = nil}

  /// ALL_TC
  public var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  public var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  public mutating func clearLongitude() {self._longitude = nil}

  /// ALL_TC
  public var timestamp: PbSystemDateTime {
    get {return _timestamp ?? PbSystemDateTime()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// ALL_TC
  public var fix: PbLocation.Fix {
    get {return _fix ?? .none}
    set {_fix = newValue}
  }
  /// Returns true if `fix` has been explicitly set.
  public var hasFix: Bool {return self._fix != nil}
  /// Clears the value of `fix`. Subsequent reads from it will return its default value.
  public mutating func clearFix() {self._fix = nil}

  /// ALL_TC
  public var satellites: UInt32 {
    get {return _satellites ?? 0}
    set {_satellites = newValue}
  }
  /// Returns true if `satellites` has been explicitly set.
  public var hasSatellites: Bool {return self._satellites != nil}
  /// Clears the value of `satellites`. Subsequent reads from it will return its default value.
  public mutating func clearSatellites() {self._satellites = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Fix: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0
    case fix2D // = 1
    case fix3D // = 2

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .fix2D
      case 2: self = .fix3D
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .fix2D: return 1
      case .fix3D: return 2
      }
    }

  }

  public init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _timestamp: PbSystemDateTime? = nil
  fileprivate var _fix: PbLocation.Fix? = nil
  fileprivate var _satellites: UInt32? = nil
}

#if swift(>=4.2)

extension PbLocation.Fix: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
///Provides information when a sensor has been offline.
///! All fields are required.
public struct PbSensorOffline {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// index of first offline point
  public var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  public var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStartIndex() {self._startIndex = nil}

  /// index of last offline point, can have same value than start_index
  public var stopIndex: UInt32 {
    get {return _stopIndex ?? 0}
    set {_stopIndex = newValue}
  }
  /// Returns true if `stopIndex` has been explicitly set.
  public var hasStopIndex: Bool {return self._stopIndex != nil}
  /// Clears the value of `stopIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStopIndex() {self._stopIndex = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startIndex: UInt32? = nil
  fileprivate var _stopIndex: UInt32? = nil
}

public struct PbVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Volume
  /// Range [0 - 100] %
  public var volume: UInt32 {
    get {return _volume ?? 0}
    set {_volume = newValue}
  }
  /// Returns true if `volume` has been explicitly set.
  public var hasVolume: Bool {return self._volume != nil}
  /// Clears the value of `volume`. Subsequent reads from it will return its default value.
  public mutating func clearVolume() {self._volume = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _volume: UInt32? = nil
}

public struct PbStrideSensorCalibSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var runningFactor: Float {
    get {return _runningFactor ?? 0}
    set {_runningFactor = newValue}
  }
  /// Returns true if `runningFactor` has been explicitly set.
  public var hasRunningFactor: Bool {return self._runningFactor != nil}
  /// Clears the value of `runningFactor`. Subsequent reads from it will return its default value.
  public mutating func clearRunningFactor() {self._runningFactor = nil}

  public var calibType: PbStrideSensorCalibSettings.PbStrideCalibType {
    get {return _calibType ?? .strideCalibManual}
    set {_calibType = newValue}
  }
  /// Returns true if `calibType` has been explicitly set.
  public var hasCalibType: Bool {return self._calibType != nil}
  /// Clears the value of `calibType`. Subsequent reads from it will return its default value.
  public mutating func clearCalibType() {self._calibType = nil}

  /// GUITAR BUGATTI JEEP ICON MESSI PELE CHIRON MACAN CAYENNE AMPERA TAYCAN ABARTH ACE METRO
  public var runningFactorSource: PbStrideSensorCalibSettings.PbRunningFactorSource {
    get {return _runningFactorSource ?? .runningFactorSourceDefault}
    set {_runningFactorSource = newValue}
  }
  /// Returns true if `runningFactorSource` has been explicitly set.
  public var hasRunningFactorSource: Bool {return self._runningFactorSource != nil}
  /// Clears the value of `runningFactorSource`. Subsequent reads from it will return its default value.
  public mutating func clearRunningFactorSource() {self._runningFactorSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PbStrideCalibType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case strideCalibManual // = 0
    case strideCalibAuto // = 1

    public init() {
      self = .strideCalibManual
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .strideCalibManual
      case 1: self = .strideCalibAuto
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .strideCalibManual: return 0
      case .strideCalibAuto: return 1
      }
    }

  }

  public enum PbRunningFactorSource: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value
    case runningFactorSourceDefault // = 0

    /// Auto calibration
    case runningFactorSourceAutoCalibration // = 1

    /// Manual calibration
    case runningFactorSourceManualCalibration // = 2

    public init() {
      self = .runningFactorSourceDefault
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .runningFactorSourceDefault
      case 1: self = .runningFactorSourceAutoCalibration
      case 2: self = .runningFactorSourceManualCalibration
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .runningFactorSourceDefault: return 0
      case .runningFactorSourceAutoCalibration: return 1
      case .runningFactorSourceManualCalibration: return 2
      }
    }

  }

  public init() {}

  fileprivate var _runningFactor: Float? = nil
  fileprivate var _calibType: PbStrideSensorCalibSettings.PbStrideCalibType? = nil
  fileprivate var _runningFactorSource: PbStrideSensorCalibSettings.PbRunningFactorSource? = nil
}

#if swift(>=4.2)

extension PbStrideSensorCalibSettings.PbStrideCalibType: CaseIterable {
  // Support synthesized by the compiler.
}

extension PbStrideSensorCalibSettings.PbRunningFactorSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct PbWeek {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO-8601 week number
  public var weekNumberIso8601: UInt32 {
    get {return _weekNumberIso8601 ?? 0}
    set {_weekNumberIso8601 = newValue}
  }
  /// Returns true if `weekNumberIso8601` has been explicitly set.
  public var hasWeekNumberIso8601: Bool {return self._weekNumberIso8601 != nil}
  /// Clears the value of `weekNumberIso8601`. Subsequent reads from it will return its default value.
  public mutating func clearWeekNumberIso8601() {self._weekNumberIso8601 = nil}

  /// Year
  public var year: UInt32 {
    get {return _year ?? 0}
    set {_year = newValue}
  }
  /// Returns true if `year` has been explicitly set.
  public var hasYear: Bool {return self._year != nil}
  /// Clears the value of `year`. Subsequent reads from it will return its default value.
  public mutating func clearYear() {self._year = nil}

  /// Range [-720 - 840] minutes
  public var timeZoneOffset: Int32 {
    get {return _timeZoneOffset ?? 0}
    set {_timeZoneOffset = newValue}
  }
  /// Returns true if `timeZoneOffset` has been explicitly set.
  public var hasTimeZoneOffset: Bool {return self._timeZoneOffset != nil}
  /// Clears the value of `timeZoneOffset`. Subsequent reads from it will return its default value.
  public mutating func clearTimeZoneOffset() {self._timeZoneOffset = nil}

  /// Start day of the week at creation
  public var weekStartDay: PbStartDayOfWeek {
    get {return _weekStartDay ?? .monday}
    set {_weekStartDay = newValue}
  }
  /// Returns true if `weekStartDay` has been explicitly set.
  public var hasWeekStartDay: Bool {return self._weekStartDay != nil}
  /// Clears the value of `weekStartDay`. Subsequent reads from it will return its default value.
  public mutating func clearWeekStartDay() {self._weekStartDay = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _weekNumberIso8601: UInt32? = nil
  fileprivate var _year: UInt32? = nil
  fileprivate var _timeZoneOffset: Int32? = nil
  fileprivate var _weekStartDay: PbStartDayOfWeek? = nil
}

///
///Source for samples.
///! All fields are required.
public struct PbSampleSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sample source 
  public var sampleSourceType: PbSampleSourceType {
    get {return _sampleSourceType ?? .sampleSourceTypeUndefined}
    set {_sampleSourceType = newValue}
  }
  /// Returns true if `sampleSourceType` has been explicitly set.
  public var hasSampleSourceType: Bool {return self._sampleSourceType != nil}
  /// Clears the value of `sampleSourceType`. Subsequent reads from it will return its default value.
  public mutating func clearSampleSourceType() {self._sampleSourceType = nil}

  /// Index of first point for a certain sample source
  public var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  public var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStartIndex() {self._startIndex = nil}

  /// Index of last point for a certain sample source, can have same value than start_index
  public var stopIndex: UInt32 {
    get {return _stopIndex ?? 0}
    set {_stopIndex = newValue}
  }
  /// Returns true if `stopIndex` has been explicitly set.
  public var hasStopIndex: Bool {return self._stopIndex != nil}
  /// Clears the value of `stopIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStopIndex() {self._stopIndex = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sampleSourceType: PbSampleSourceType? = nil
  fileprivate var _startIndex: UInt32? = nil
  fileprivate var _stopIndex: UInt32? = nil
}

public struct PbSensorCalibrationOffset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source of the data which offset is calculated, e.g. wristmetrics uses SAMPLE_SOURCE_TYPE_WRIST_METRICS
  public var sampleSourceType: PbSampleSourceType {
    get {return _sampleSourceType ?? .sampleSourceTypeUndefined}
    set {_sampleSourceType = newValue}
  }
  /// Returns true if `sampleSourceType` has been explicitly set.
  public var hasSampleSourceType: Bool {return self._sampleSourceType != nil}
  /// Clears the value of `sampleSourceType`. Subsequent reads from it will return its default value.
  public mutating func clearSampleSourceType() {self._sampleSourceType = nil}

  /// Calibration offset value
  public var speedCalOffset: Float {
    get {return _speedCalOffset ?? 0}
    set {_speedCalOffset = newValue}
  }
  /// Returns true if `speedCalOffset` has been explicitly set.
  public var hasSpeedCalOffset: Bool {return self._speedCalOffset != nil}
  /// Clears the value of `speedCalOffset`. Subsequent reads from it will return its default value.
  public mutating func clearSpeedCalOffset() {self._speedCalOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sampleSourceType: PbSampleSourceType? = nil
  fileprivate var _speedCalOffset: Float? = nil
}

public struct PbCalibrationSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the calibrate-able measurement (SAMPLE_TYPE_SPEED etc.)
  public var sampleType: PbSampleType {
    get {return _sampleType ?? .sampleTypeUndefined}
    set {_sampleType = newValue}
  }
  /// Returns true if `sampleType` has been explicitly set.
  public var hasSampleType: Bool {return self._sampleType != nil}
  /// Clears the value of `sampleType`. Subsequent reads from it will return its default value.
  public mutating func clearSampleType() {self._sampleType = nil}

  /// Calibration value use enable on/off (existing calibration value is used if true).
  public var calibrationEnabled: Bool {
    get {return _calibrationEnabled ?? false}
    set {_calibrationEnabled = newValue}
  }
  /// Returns true if `calibrationEnabled` has been explicitly set.
  public var hasCalibrationEnabled: Bool {return self._calibrationEnabled != nil}
  /// Clears the value of `calibrationEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearCalibrationEnabled() {self._calibrationEnabled = nil}

  /// Calibration calculation enable on/off. New calibration offset value for exercise is calculated if true.
  public var calibrationCalculationEnabled: Bool {
    get {return _calibrationCalculationEnabled ?? false}
    set {_calibrationCalculationEnabled = newValue}
  }
  /// Returns true if `calibrationCalculationEnabled` has been explicitly set.
  public var hasCalibrationCalculationEnabled: Bool {return self._calibrationCalculationEnabled != nil}
  /// Clears the value of `calibrationCalculationEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearCalibrationCalculationEnabled() {self._calibrationCalculationEnabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sampleType: PbSampleType? = nil
  fileprivate var _calibrationEnabled: Bool? = nil
  fileprivate var _calibrationCalculationEnabled: Bool? = nil
}

public struct PbAccelerationMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source of the acceleration data i.e location of the sensor (SAMPLE_SOURCE_TYPE_WRIST_METRICS etc.)
  public var sampleSourceType: PbSampleSourceType {
    get {return _sampleSourceType ?? .sampleSourceTypeUndefined}
    set {_sampleSourceType = newValue}
  }
  /// Returns true if `sampleSourceType` has been explicitly set.
  public var hasSampleSourceType: Bool {return self._sampleSourceType != nil}
  /// Clears the value of `sampleSourceType`. Subsequent reads from it will return its default value.
  public mutating func clearSampleSourceType() {self._sampleSourceType = nil}

  /// Calibration settings
  public var calibrationSettings: [PbCalibrationSettings] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sampleSourceType: PbSampleSourceType? = nil
}

public struct PbAutoPause {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Used trigger 
  public var trigger: PbAutoPause.PbAutoPauseTrigger {
    get {return _trigger ?? .autoPauseOff}
    set {_trigger = newValue}
  }
  /// Returns true if `trigger` has been explicitly set.
  public var hasTrigger: Bool {return self._trigger != nil}
  /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
  public mutating func clearTrigger() {self._trigger = nil}

  /// Speed threshold for pausing/resuming
  public var speedThreshold: Float {
    get {return _speedThreshold ?? 0}
    set {_speedThreshold = newValue}
  }
  /// Returns true if `speedThreshold` has been explicitly set.
  public var hasSpeedThreshold: Bool {return self._speedThreshold != nil}
  /// Clears the value of `speedThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearSpeedThreshold() {self._speedThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Available trigger types
  public enum PbAutoPauseTrigger: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case autoPauseOff // = 0
    case autoPauseTriggerSpeed // = 1

    public init() {
      self = .autoPauseOff
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .autoPauseOff
      case 1: self = .autoPauseTriggerSpeed
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .autoPauseOff: return 0
      case .autoPauseTriggerSpeed: return 1
      }
    }

  }

  public init() {}

  fileprivate var _trigger: PbAutoPause.PbAutoPauseTrigger? = nil
  fileprivate var _speedThreshold: Float? = nil
}

#if swift(>=4.2)

extension PbAutoPause.PbAutoPauseTrigger: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Autolap related settings
public struct PbAutoLapSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Autolap mode
  public var automaticLap: PbAutoLapSettings.PbAutomaticLap {
    get {return _automaticLap ?? .automaticLapOff}
    set {_automaticLap = newValue}
  }
  /// Returns true if `automaticLap` has been explicitly set.
  public var hasAutomaticLap: Bool {return self._automaticLap != nil}
  /// Clears the value of `automaticLap`. Subsequent reads from it will return its default value.
  public mutating func clearAutomaticLap() {self._automaticLap = nil}

  /// Distance based autolap trigger
  /// range [100 - 99900] m
  public var automaticLapDistance: Float {
    get {return _automaticLapDistance ?? 0}
    set {_automaticLapDistance = newValue}
  }
  /// Returns true if `automaticLapDistance` has been explicitly set.
  public var hasAutomaticLapDistance: Bool {return self._automaticLapDistance != nil}
  /// Clears the value of `automaticLapDistance`. Subsequent reads from it will return its default value.
  public mutating func clearAutomaticLapDistance() {self._automaticLapDistance = nil}

  /// Duration based autolap trigger
  public var automaticLapDuration: PbDuration {
    get {return _automaticLapDuration ?? PbDuration()}
    set {_automaticLapDuration = newValue}
  }
  /// Returns true if `automaticLapDuration` has been explicitly set.
  public var hasAutomaticLapDuration: Bool {return self._automaticLapDuration != nil}
  /// Clears the value of `automaticLapDuration`. Subsequent reads from it will return its default value.
  public mutating func clearAutomaticLapDuration() {self._automaticLapDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Automatic lap setting modes.
  ///  NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
  ///  of the enum 
  public enum PbAutomaticLap: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case automaticLapOff // = 1
    case automaticLapDistance // = 2
    case automaticLapDuration // = 3
    case automaticLapLocation // = 4

    public init() {
      self = .automaticLapOff
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .automaticLapOff
      case 2: self = .automaticLapDistance
      case 3: self = .automaticLapDuration
      case 4: self = .automaticLapLocation
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .automaticLapOff: return 1
      case .automaticLapDistance: return 2
      case .automaticLapDuration: return 3
      case .automaticLapLocation: return 4
      }
    }

  }

  public init() {}

  fileprivate var _automaticLap: PbAutoLapSettings.PbAutomaticLap? = nil
  fileprivate var _automaticLapDistance: Float? = nil
  fileprivate var _automaticLapDuration: PbDuration? = nil
}

#if swift(>=4.2)

extension PbAutoLapSettings.PbAutomaticLap: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct PbCardioLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Load from activity data within the calculated time period
  public var activityLoad: Float {
    get {return _activityLoad ?? 0}
    set {_activityLoad = newValue}
  }
  /// Returns true if `activityLoad` has been explicitly set.
  public var hasActivityLoad: Bool {return self._activityLoad != nil}
  /// Clears the value of `activityLoad`. Subsequent reads from it will return its default value.
  public mutating func clearActivityLoad() {self._activityLoad = nil}

  /// Load from exercises within the calculated time period
  public var exerciseLoad: Float {
    get {return _exerciseLoad ?? 0}
    set {_exerciseLoad = newValue}
  }
  /// Returns true if `exerciseLoad` has been explicitly set.
  public var hasExerciseLoad: Bool {return self._exerciseLoad != nil}
  /// Clears the value of `exerciseLoad`. Subsequent reads from it will return its default value.
  public mutating func clearExerciseLoad() {self._exerciseLoad = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _activityLoad: Float? = nil
  fileprivate var _exerciseLoad: Float? = nil
}

///
///Perceived load a.k.a. RPE Load a.k.a. Subjective Load: internal training load of a session.
///Calculated by multiplying the fields below: session_rpe * duration in minutes
///Note! session_rpe can be modified afterwards in TC, mobile or service
public struct PbPerceivedLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hardness of the exercise    
  public var sessionRpe: PbSessionRPE {
    get {return _sessionRpe ?? .rpeModerate}
    set {_sessionRpe = newValue}
  }
  /// Returns true if `sessionRpe` has been explicitly set.
  public var hasSessionRpe: Bool {return self._sessionRpe != nil}
  /// Clears the value of `sessionRpe`. Subsequent reads from it will return its default value.
  public mutating func clearSessionRpe() {self._sessionRpe = nil}

  /// duration in seconds
  public var duration: UInt32 {
    get {return _duration ?? 0}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionRpe: PbSessionRPE? = nil
  fileprivate var _duration: UInt32? = nil
}

// MARK: - Extension support defined in types.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_FieldOptions {

  /// ALL_TC
  public var type: PbDataType {
    get {return getExtensionValue(ext: Extensions_type) ?? .undefined}
    set {setExtensionValue(ext: Extensions_type, value: newValue)}
  }
  /// Returns true if extension `Extensions_type`
  /// has been explicitly set.
  public var hasType: Bool {
    return hasExtensionValue(ext: Extensions_type)
  }
  /// Clears the value of extension `Extensions_type`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearType() {
    clearExtensionValue(ext: Extensions_type)
  }

  /// ALL_TC
  public var range: PbRangeOptions {
    get {return getExtensionValue(ext: Extensions_range) ?? PbRangeOptions()}
    set {setExtensionValue(ext: Extensions_range, value: newValue)}
  }
  /// Returns true if extension `Extensions_range`
  /// has been explicitly set.
  public var hasRange: Bool {
    return hasExtensionValue(ext: Extensions_range)
  }
  /// Clears the value of extension `Extensions_range`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearRange() {
    clearExtensionValue(ext: Extensions_range)
  }
}

extension SwiftProtobuf.Google_Protobuf_MessageOptions {

  /// ALL_TC
  public var isUnion: Bool {
    get {return getExtensionValue(ext: Extensions_is_union) ?? false}
    set {setExtensionValue(ext: Extensions_is_union, value: newValue)}
  }
  /// Returns true if extension `Extensions_is_union`
  /// has been explicitly set.
  public var hasIsUnion: Bool {
    return hasExtensionValue(ext: Extensions_is_union)
  }
  /// Clears the value of extension `Extensions_is_union`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearIsUnion() {
    clearExtensionValue(ext: Extensions_is_union)
  }

}

// MARK: - File's ExtensionMap: Types_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let Types_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Extensions_type,
  Extensions_is_union,
  Extensions_range
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// ALL_TC
public let Extensions_type = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalEnumExtensionField<PbDataType>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 50000,
  fieldName: "type"
)

/// ALL_TC
public let Extensions_is_union = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufBool>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
  _protobuf_fieldNumber: 50001,
  fieldName: "is_union"
)

/// ALL_TC
public let Extensions_range = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<PbRangeOptions>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 50003,
  fieldName: "range"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PbDataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "INHERITED"),
    2: .same(proto: "ENUM"),
    3: .same(proto: "MILLIS"),
    4: .same(proto: "SECOND"),
    5: .same(proto: "MINUTE"),
    6: .same(proto: "HOUR"),
    7: .same(proto: "HOURS"),
    8: .same(proto: "DAY"),
    9: .same(proto: "MONTH"),
    10: .same(proto: "YEAR"),
    11: .same(proto: "WEIGHT"),
    12: .same(proto: "HEIGHT"),
    13: .same(proto: "VO2MAX"),
    20: .same(proto: "HEARTRATE"),
    21: .same(proto: "HR_PERCENT"),
    22: .same(proto: "HR_RESERVE"),
    23: .same(proto: "SPEED"),
    24: .same(proto: "CADENCE"),
    25: .same(proto: "ALTITUDE"),
    26: .same(proto: "POWER"),
    27: .same(proto: "POWER_LRB"),
    28: .same(proto: "POWER_PI"),
    29: .same(proto: "TEMPERATURE"),
    30: .same(proto: "ACTIVITY"),
    31: .same(proto: "STRIDE_LENGTH"),
    32: .same(proto: "INCLINE"),
    33: .same(proto: "DECLINE"),
    52: .same(proto: "DISTANCE"),
    53: .same(proto: "ENERGY"),
    54: .same(proto: "FAT_PERCENTS"),
    55: .same(proto: "ASCENT"),
    56: .same(proto: "DESCENT"),
    57: .same(proto: "LATITUDE"),
    58: .same(proto: "LONGITUDE"),
    59: .same(proto: "HERTZ"),
    60: .same(proto: "PERCENT"),
    61: .same(proto: "CUMULATED_ACTIVITY_DAY"),
    62: .same(proto: "RUNNING_INDEX"),
    63: .same(proto: "RR_INTERVAL"),
    64: .same(proto: "Z_INDEX"),
    65: .same(proto: "EXERCISE_TARGET_INDEX"),
    66: .same(proto: "TIME_ZONE_OFFSET"),
    67: .same(proto: "WHEEL_SIZE"),
    68: .same(proto: "FITNESS_CLASS"),
    69: .same(proto: "ACCELERATION"),
    70: .same(proto: "CRANK_LENGTH"),
    71: .same(proto: "ANGLE_DEGREE"),
    72: .same(proto: "NEWTON"),
    73: .same(proto: "FUNCTIONAL_THRESHOLD_POWER"),
    74: .same(proto: "CALORIES"),
    75: .same(proto: "SPEED_CALIBRATION_OFFSET"),
    76: .same(proto: "WEEK"),
    77: .same(proto: "CARDIO_LOAD"),
    78: .same(proto: "MAXIMUM_AEROBIC_POWER"),
    79: .same(proto: "MAXIMUM_AEROBIC_SPEED"),
    80: .same(proto: "MUSCLE_LOAD"),
    81: .same(proto: "PERCEIVED_LOAD"),
  ]
}

extension PbHeartRateView: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HEART_RATE_VIEW_BPM"),
    2: .same(proto: "HEART_RATE_VIEW_PERCENTS_OF_HR_RESERVE"),
    3: .same(proto: "HEART_RATE_VIEW_PERCENTS_OF_MAX_HR"),
  ]
}

extension PbUnitSystem: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "METRIC"),
    2: .same(proto: "IMPERIAL"),
  ]
}

extension PbTimeSelection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TIME_1"),
    2: .same(proto: "TIME_2"),
  ]
}

extension PbTimeFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TIME_FORMAT_24H"),
    2: .same(proto: "TIME_FORMAT_12H"),
  ]
}

extension PbTimeFormatSeparator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TIME_FORMAT_SEPARATOR_DOT"),
    2: .same(proto: "TIME_FORMAT_SEPARATOR_COLON"),
  ]
}

extension PbStartDayOfWeek: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MONDAY"),
    2: .same(proto: "SATURDAY"),
    3: .same(proto: "SUNDAY"),
  ]
}

extension PbDateFormatSeparator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DOT"),
    2: .same(proto: "SLASH"),
    3: .same(proto: "HYPHEN"),
  ]
}

extension PbDateFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DD_MM_YYYY"),
    2: .same(proto: "MM_DD_YYYY"),
    3: .same(proto: "YYYY_MM_DD"),
  ]
}

extension PbFeatureType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FEATURE_TYPE_HEART_RATE"),
    2: .same(proto: "FEATURE_TYPE_RR_INTERVAL"),
    3: .same(proto: "FEATURE_TYPE_SPEED"),
    4: .same(proto: "FEATURE_TYPE_DISTANCE"),
    5: .same(proto: "FEATURE_TYPE_BIKE_CADENCE"),
    6: .same(proto: "FEATURE_TYPE_BIKE_POWER"),
    7: .same(proto: "FEATURE_TYPE_GPS_LOCATION"),
    8: .same(proto: "FEATURE_TYPE_RUNNING_CADENCE"),
    9: .same(proto: "FEATURE_TYPE_PRESS_TEMPERATURE"),
    10: .same(proto: "FEATURE_TYPE_ALTITUDE"),
    11: .same(proto: "FEATURE_TYPE_STEPS"),
    12: .same(proto: "FEATURE_TYPE_ACTIVITY"),
    13: .same(proto: "FEATURE_TYPE_STRIDE_LENGTH"),
    14: .same(proto: "FEATURE_TYPE_RSC_MOVING_TYPE"),
    15: .same(proto: "FEATURE_TYPE_JUMP_HEIGTH"),
    16: .same(proto: "FEATURE_TYPE_COMPASS_HEADING"),
    17: .same(proto: "FEATURE_TYPE_GPS_SPEED"),
    18: .same(proto: "FEATURE_TYPE_GPS_DISTANCE"),
    19: .same(proto: "FEATURE_TYPE_GPS_ALTITUDE"),
    20: .same(proto: "FEATURE_TYPE_BIKE_WHEEL_REVOLUTION"),
    21: .same(proto: "FEATURE_TYPE_BIKE_CRANK_REVOLUTION"),
    22: .same(proto: "FEATURE_TYPE_AS_SPEED"),
    23: .same(proto: "FEATURE_TYPE_AS_CADENCE"),
    24: .same(proto: "FEATURE_TYPE_AS_DISTANCE"),
    25: .same(proto: "FEATURE_TYPE_AS_SWR_STATE"),
    26: .same(proto: "FEATURE_TYPE_BATTERY_LEVEL"),
    27: .same(proto: "FEATURE_TYPE_FILE_TRANSFER"),
    28: .same(proto: "FEATURE_TYPE_PUSH_NOTIFICATIONS"),
    29: .same(proto: "FEATURE_TYPE_WEIGHT_SCALE"),
    30: .same(proto: "FEATURE_TYPE_REMOTE_BUTTONS"),
    31: .same(proto: "FEATURE_TYPE_GOPRO"),
    32: .same(proto: "FEATURE_TYPE_PP_INTERVAL"),
    33: .same(proto: "FEATURE_TYPE_MEDIA_CONTROL"),
    34: .same(proto: "FEATURE_TYPE_MOBILE_GPS"),
  ]
}

extension PbMovingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WALKING"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "STANDING"),
  ]
}

extension PbOperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MULTIPLY"),
    2: .same(proto: "SUM"),
  ]
}

extension PbExerciseFeedback: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FEEDBACK_NONE"),
    2: .same(proto: "FEEDBACK_1"),
    3: .same(proto: "FEEDBACK_2"),
    4: .same(proto: "FEEDBACK_3"),
    5: .same(proto: "FEEDBACK_4"),
    6: .same(proto: "FEEDBACK_5"),
    7: .same(proto: "FEEDBACK_6"),
    8: .same(proto: "FEEDBACK_7"),
    9: .same(proto: "FEEDBACK_8"),
    10: .same(proto: "FEEDBACK_9"),
    11: .same(proto: "FEEDBACK_10"),
    12: .same(proto: "FEEDBACK_11"),
    13: .same(proto: "FEEDBACK_12"),
    14: .same(proto: "FEEDBACK_13"),
    15: .same(proto: "FEEDBACK_14"),
    16: .same(proto: "FEEDBACK_15"),
    17: .same(proto: "FEEDBACK_16"),
    18: .same(proto: "FEEDBACK_17"),
  ]
}

extension PbHeartRateZoneSettingSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEART_RATE_ZONE_SETTING_SOURCE_DEFAULT"),
    1: .same(proto: "HEART_RATE_ZONE_SETTING_SOURCE_THRESHOLD"),
    2: .same(proto: "HEART_RATE_ZONE_SETTING_SOURCE_FREE"),
  ]
}

extension PbPowerZoneSettingSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POWER_ZONE_SETTING_SOURCE_DEFAULT"),
    1: .same(proto: "POWER_ZONE_SETTING_SOURCE_FREE"),
  ]
}

extension PbSpeedZoneSettingSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPEED_ZONE_SETTING_SOURCE_DEFAULT"),
    1: .same(proto: "SPEED_ZONE_SETTING_SOURCE_FREE"),
  ]
}

extension PbPowerZoneCalculationMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POWER_ZONE_CALCULATION_METHOD_UNKNOWN"),
    1: .same(proto: "POWER_ZONE_CALCULATION_METHOD_FTP_BASED"),
    2: .same(proto: "POWER_ZONE_CALCULATION_METHOD_MAP_BASED"),
  ]
}

extension PbSpeedZoneCalculationMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPEED_ZONE_CALCULATION_METHOD_UNKNOWN"),
    1: .same(proto: "SPEED_ZONE_CALCULATION_METHOD_SPORT_SPECIFIC_PREDEFINED"),
    2: .same(proto: "SPEED_ZONE_CALCULATION_METHOD_MAS_BASED"),
  ]
}

extension PbMacType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAC_TYPE_PUBLIC"),
    1: .same(proto: "MAC_TYPE_STATIC"),
    2: .same(proto: "MAC_TYPE_PRIVATE_NONRESOLVABLE"),
    3: .same(proto: "MAC_TYPE_PRIVATE_RESOLVABLE"),
    4: .same(proto: "MAC_TYPE_BT_CLASSIC"),
  ]
}

extension PbSwimmingStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "OTHER"),
    0: .same(proto: "TURN"),
    10: .same(proto: "OTHER_SWIMMING"),
    11: .same(proto: "FREESTYLE"),
    12: .same(proto: "BREASTSTROKE"),
    13: .same(proto: "BACKSTROKE"),
    14: .same(proto: "BUTTERFLY"),
    15: .same(proto: "DRILL"),
  ]
}

extension PbSwimmingPoolUnits: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SWIMMING_POOL_METERS"),
    1: .same(proto: "SWIMMING_POOL_YARDS"),
  ]
}

extension PbExerciseTargetType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXERCISE_TARGET_TYPE_FREE"),
    1: .same(proto: "EXERCISE_TARGET_TYPE_VOLUME"),
    2: .same(proto: "EXERCISE_TARGET_TYPE_PHASED"),
    3: .same(proto: "EXERCISE_TARGET_TYPE_ROUTE"),
    4: .same(proto: "EXERCISE_TARGET_TYPE_STEADY_RACE_PACE"),
    5: .same(proto: "EXERCISE_TARGET_TYPE_ROUTE_RACE_PACE"),
    6: .same(proto: "EXERCISE_TARGET_TYPE_STRAVA_SEGMENT"),
    7: .same(proto: "EXERCISE_TARGET_TYPE_STRENGTH_TRAINING"),
  ]
}

extension Buttons: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUTTON_PLUS"),
    1: .same(proto: "BUTTON_MINUS"),
    2: .same(proto: "BUTTON_OK"),
    3: .same(proto: "BUTTON_LIGHT"),
    4: .same(proto: "BUTTON_BACK"),
  ]
}

extension ButtonState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUTTON_PRESSED"),
    1: .same(proto: "BUTTON_RELEASED"),
  ]
}

extension PbSampleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAMPLE_TYPE_UNDEFINED"),
    1: .same(proto: "SAMPLE_TYPE_HEART_RATE"),
    2: .same(proto: "SAMPLE_TYPE_CADENCE"),
    3: .same(proto: "SAMPLE_TYPE_ALTITUDE"),
    4: .same(proto: "SAMPLE_TYPE_ALTITUDE_CALIBRATION"),
    5: .same(proto: "SAMPLE_TYPE_TEMPERATURE"),
    6: .same(proto: "SAMPLE_TYPE_SPEED"),
    7: .same(proto: "SAMPLE_TYPE_DISTANCE"),
    8: .same(proto: "SAMPLE_TYPE_STRIDE_LENGTH"),
    9: .same(proto: "SAMPLE_TYPE_STRIDE_CALIBRATION"),
    10: .same(proto: "SAMPLE_TYPE_FORWARD_ACCELERATION"),
    11: .same(proto: "SAMPLE_TYPE_MOVING_TYPE"),
    12: .same(proto: "SAMPLE_TYPE_LEFT_PEDAL_POWER"),
    13: .same(proto: "SAMPLE_TYPE_RIGHT_PEDAL_POWER"),
    14: .same(proto: "SAMPLE_TYPE_LEFT_PEDAL_POWER_CALIBRATION"),
    15: .same(proto: "SAMPLE_TYPE_RIGHT_PEDAL_POWER_CALIBRATION"),
    16: .same(proto: "SAMPLE_TYPE_RR_INTERVAL"),
    17: .same(proto: "SAMPLE_TYPE_ACCELERATION_MAD"),
  ]
}

extension PbSampleSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAMPLE_SOURCE_TYPE_UNDEFINED"),
    1: .same(proto: "SAMPLE_SOURCE_TYPE_OFFLINE"),
    2: .same(proto: "SAMPLE_SOURCE_TYPE_HEART_RATE"),
    3: .same(proto: "SAMPLE_SOURCE_TYPE_HEART_RATE_BLE"),
    4: .same(proto: "SAMPLE_SOURCE_TYPE_HEART_RATE_5_KHZ"),
    5: .same(proto: "SAMPLE_SOURCE_TYPE_HEART_RATE_OPTICAL"),
    6: .same(proto: "SAMPLE_SOURCE_TYPE_GPS"),
    7: .same(proto: "SAMPLE_SOURCE_TYPE_STRIDE"),
    8: .same(proto: "SAMPLE_SOURCE_TYPE_WRIST_METRICS"),
    9: .same(proto: "SAMPLE_SOURCE_TYPE_CHEST_METRICS"),
    10: .same(proto: "SAMPLE_SOURCE_TYPE_BIKE_PEDAL"),
    11: .same(proto: "SAMPLE_SOURCE_TYPE_BIKE_WHEEL"),
    12: .same(proto: "SAMPLE_SOURCE_TYPE_BIKE_CRANK"),
    13: .same(proto: "SAMPLE_SOURCE_TYPE_COMBINED_CHEST_METRICS_AND_GPS"),
    14: .same(proto: "SAMPLE_SOURCE_TYPE_UPPER_BACK_METRICS"),
    15: .same(proto: "SAMPLE_SOURCE_TYPE_COMBINED_UPPER_BACK_METRICS_AND_GPS"),
  ]
}

extension PbAltitudeSetting: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALTITUDE_OFF"),
    1: .same(proto: "ALTITUDE_ON"),
  ]
}

extension PbGPSSetting: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GPS_OFF"),
    1: .same(proto: "GPS_ON_NORMAL"),
    2: .same(proto: "GPS_ON_LONG"),
    3: .same(proto: "GPS_ON_10_HZ"),
    4: .same(proto: "GPS_ON_MEDIUM"),
  ]
}

extension PbHeartTouch: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HEART_TOUCH_OFF"),
    2: .same(proto: "HEART_TOUCH_ACTIVATE_BACKLIGHT"),
    3: .same(proto: "HEART_TOUCH_SHOW_PREVIOUS_LAP"),
    4: .same(proto: "HEART_TOUCH_SHOW_TIME_OF_DAY"),
  ]
}

extension PbTapButtonAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TAP_BUTTON_OFF"),
    2: .same(proto: "TAP_BUTTON_TAKE_LAP"),
    3: .same(proto: "TAP_BUTTON_CHANGE_TRAINING_VIEW"),
    4: .same(proto: "TAP_BUTTON_ACTIVATE_BACKLIGHT"),
  ]
}

extension PbHandedness: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WU_IN_LEFT_HAND"),
    2: .same(proto: "WU_IN_RIGHT_HAND"),
    3: .same(proto: "WU_IN_NECKLACE"),
  ]
}

extension PbDeviceLocation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_LOCATION_UNDEFINED"),
    1: .same(proto: "DEVICE_LOCATION_OTHER"),
    2: .same(proto: "DEVICE_LOCATION_WRIST_LEFT"),
    3: .same(proto: "DEVICE_LOCATION_WRIST_RIGHT"),
    4: .same(proto: "DEVICE_LOCATION_NECKLACE"),
    5: .same(proto: "DEVICE_LOCATION_CHEST"),
    6: .same(proto: "DEVICE_LOCATION_UPPER_BACK"),
    7: .same(proto: "DEVICE_LOCATION_FOOT_LEFT"),
    8: .same(proto: "DEVICE_LOCATION_FOOT_RIGHT"),
    9: .same(proto: "DEVICE_LOCATION_LOWER_ARM_LEFT"),
    10: .same(proto: "DEVICE_LOCATION_LOWER_ARM_RIGHT"),
    11: .same(proto: "DEVICE_LOCATION_UPPER_ARM_LEFT"),
    12: .same(proto: "DEVICE_LOCATION_UPPER_ARM_RIGHT"),
    13: .same(proto: "DEVICE_LOCATION_BIKE_MOUNT"),
  ]
}

extension PbSessionRPE: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RPE_NONE"),
    2: .same(proto: "RPE_EASY"),
    3: .same(proto: "RPE_LIGHT"),
    4: .same(proto: "RPE_FAIRLY_BRISK"),
    5: .same(proto: "RPE_BRISK"),
    6: .same(proto: "RPE_MODERATE"),
    7: .same(proto: "RPE_FAIRLY_HARD"),
    8: .same(proto: "RPE_HARD"),
    9: .same(proto: "RPE_EXHAUSTING"),
    10: .same(proto: "RPE_EXTREME"),
  ]
}

extension PbMuscleSoreness: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "MS_UNDEFINED"),
    0: .same(proto: "MS_NONE"),
    1: .same(proto: "MS_SOME"),
    2: .same(proto: "MS_MUCH"),
  ]
}

extension PbOverallFatigue: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "OF_UNDEFINED"),
    0: .same(proto: "OF_NORMAL"),
    1: .same(proto: "OF_A_LITTLE"),
    2: .same(proto: "OF_MUCH"),
  ]
}

extension PbSleepUserRating: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "PB_SLEPT_UNDEFINED"),
    0: .same(proto: "PB_SLEPT_POORLY"),
    1: .same(proto: "PB_SLEPT_SOMEWHAT_POORLY"),
    2: .same(proto: "PB_SLEPT_NEITHER_POORLY_NOR_WELL"),
    3: .same(proto: "PB_SLEPT_SOMEWHAT_WELL"),
    4: .same(proto: "PB_SLEPT_WELL"),
  ]
}

extension PbDailyBalanceFeedback: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "DB_NOT_CALCULATED"),
    0: .same(proto: "DB_SICK"),
    1: .same(proto: "DB_FATIGUE_TRY_TO_REDUCE_TRAINING_LOAD_INJURED"),
    2: .same(proto: "DB_FATIGUE_TRY_TO_REDUCE_TRAINING_LOAD"),
    3: .same(proto: "DB_LIMITED_TRAINING_RESPONSE_OTHER_INJURED"),
    4: .same(proto: "DB_LIMITED_TRAINING_RESPONSE_OTHER"),
    5: .same(proto: "DB_RESPONDING_WELL_CAN_CONTINUE_IF_INJURY_ALLOWS"),
    6: .same(proto: "DB_RESPONDING_WELL_CAN_CONTINUE"),
    7: .same(proto: "DB_YOU_COULD_DO_MORE_TRAINING_IF_INJURY_ALLOWS"),
    8: .same(proto: "DB_YOU_COULD_DO_MORE_TRAINING"),
    9: .same(proto: "DB_YOU_SEEM_TO_BE_STRAINED_INJURED"),
    10: .same(proto: "DB_YOU_SEEM_TO_BE_STRAINED"),
  ]
}

extension PbReadinessForSpeedAndStrengthTraining: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "RSST_NOT_CALCULATED"),
    0: .same(proto: "RSST_A1_RECOVERED_READY_FOR_ALL_TRAINING"),
    1: .same(proto: "RSST_A2_RECOVERED_READY_FOR_ALL_TRAINING_IF_FEELING_OK_NIGHTLY_RECHARGE_COMPROMISED"),
    2: .same(proto: "RSST_A3_RECOVERED_READY_FOR_ALL_TRAINING_IF_FEELING_OK_POSSIBLY_STRESSED"),
    3: .same(proto: "RSST_A4_RECOVERED_READY_FOR_SPEED_AND_STRENGTH_TRAINING"),
    4: .same(proto: "RSST_B1_RECOVERED_READY_FOR_SPEED_AND_STRENGTH_TRAINING_AND_LIGHT_CARDIO"),
    5: .same(proto: "RSST_B2_RECOVERED_READY_FOR_SPEED_AND_STRENGTH_TRAINING_AND_LIGHT_CARDIO_POOR_NIGHTLY_RECHARGE"),
    6: .same(proto: "RSST_B3_RECOVERED_READY_FOR_SPEED_AND_STRENGTH_TRAINING_AND_LIGHT_CARDIO_POOR_CARDIO_RECOVERY"),
    7: .same(proto: "RSST_B4_NOT_RECOVERED_NO_LEG_TRAINING_OR_INTENSIVE_CARDIO"),
    8: .same(proto: "RSST_B5_NOT_RECOVERED_NO_LEG_TRAINING_OR_INTENSIVE_CARDIO_POOR_NIGHTLY_RECHARGE"),
    9: .same(proto: "RSST_C1_NOT_RECOVERED_NO_STRENGTH_OR_INTENSIVE_CARDIO"),
    10: .same(proto: "RSST_C2_NOT_RECOVERED_NO_STRENGTH_OR_INTENSIVE_CARDIO_POOR_NIGHTLY_RECHARGE"),
    11: .same(proto: "RSST_D1_RECOVERED_BUT_INJURY_AND_ILLNESS_RISK_CAUSED_BY_CARDIO_TRAINING"),
    12: .same(proto: "RSST_D2_NOT_RECOVERED_AND_INJURY_AND_ILLNESS_RISK_CAUSED_BY_CARDIO_TRAINING"),
  ]
}

extension PbStrengthTrainingRoundRepetitionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
  ]
}

extension PbStrengthTrainingWorkoutPhase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORK"),
    1: .same(proto: "WARM_UP"),
    2: .same(proto: "COOL_DOWN"),
  ]
}

extension PbRangeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbRangeOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_value"),
    2: .standard(proto: "max_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._minValue) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._maxValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbRangeOptions, rhs: PbRangeOptions) -> Bool {
    if lhs._minValue != rhs._minValue {return false}
    if lhs._maxValue != rhs._maxValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbDate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
  ]

  public var isInitialized: Bool {
    if self._year == nil {return false}
    if self._month == nil {return false}
    if self._day == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._day) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._year {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._month {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._day {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbDate, rhs: PbDate) -> Bool {
    if lhs._year != rhs._year {return false}
    if lhs._month != rhs._month {return false}
    if lhs._day != rhs._day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
    2: .same(proto: "minute"),
    3: .same(proto: "seconds"),
    4: .same(proto: "millis"),
  ]

  public var isInitialized: Bool {
    if self._hour == nil {return false}
    if self._minute == nil {return false}
    if self._seconds == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._hour) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._minute) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._seconds) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._millis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hour {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minute {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._seconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._millis {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbTime, rhs: PbTime) -> Bool {
    if lhs._hour != rhs._hour {return false}
    if lhs._minute != rhs._minute {return false}
    if lhs._seconds != rhs._seconds {return false}
    if lhs._millis != rhs._millis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSystemDateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSystemDateTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .same(proto: "trusted"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if self._trusted == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._trusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._trusted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSystemDateTime, rhs: PbSystemDateTime) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._trusted != rhs._trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbLocalDateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbLocalDateTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .standard(proto: "OBSOLETE_trusted"),
    4: .standard(proto: "time_zone_offset"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if self._obsoleteTrusted == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._obsoleteTrusted) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._timeZoneOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._obsoleteTrusted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeZoneOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbLocalDateTime, rhs: PbLocalDateTime) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._obsoleteTrusted != rhs._obsoleteTrusted {return false}
    if lhs._timeZoneOffset != rhs._timeZoneOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbLocalDateTimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbLocalDateTimeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
  ]

  fileprivate class _StorageClass {
    var _startTime: PbLocalDateTime? = nil
    var _endTime: PbLocalDateTime? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startTime = source._startTime
      _endTime = source._endTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._startTime, !v.isInitialized {return false}
      if let v = _storage._endTime, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbLocalDateTimeRange, rhs: PbLocalDateTimeRange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbDuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbDuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hours"),
    2: .same(proto: "minutes"),
    3: .same(proto: "seconds"),
    4: .same(proto: "millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._hours) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._minutes) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._seconds) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._millis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hours {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minutes {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._seconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._millis {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbDuration, rhs: PbDuration) -> Bool {
    if lhs._hours != rhs._hours {return false}
    if lhs._minutes != rhs._minutes {return false}
    if lhs._seconds != rhs._seconds {return false}
    if lhs._millis != rhs._millis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "fix"),
    5: .same(proto: "satellites"),
  ]

  public var isInitialized: Bool {
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    if let v = self._timestamp, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._fix) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._satellites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fix {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._satellites {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbLocation, rhs: PbLocation) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._fix != rhs._fix {return false}
    if lhs._satellites != rhs._satellites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbLocation.Fix: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIX_NONE"),
    1: .same(proto: "FIX_2D"),
    2: .same(proto: "FIX_3D"),
  ]
}

extension PbSensorOffline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSensorOffline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_index"),
    2: .standard(proto: "stop_index"),
  ]

  public var isInitialized: Bool {
    if self._startIndex == nil {return false}
    if self._stopIndex == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._stopIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stopIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSensorOffline, rhs: PbSensorOffline) -> Bool {
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs._stopIndex != rhs._stopIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbVolume"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volume"),
  ]

  public var isInitialized: Bool {
    if self._volume == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._volume) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._volume {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbVolume, rhs: PbVolume) -> Bool {
    if lhs._volume != rhs._volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbStrideSensorCalibSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbStrideSensorCalibSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "running_factor"),
    2: .standard(proto: "calib_type"),
    3: .standard(proto: "running_factor_source"),
  ]

  public var isInitialized: Bool {
    if self._runningFactor == nil {return false}
    if self._calibType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._runningFactor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._calibType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._runningFactorSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._runningFactor {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._calibType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._runningFactorSource {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbStrideSensorCalibSettings, rhs: PbStrideSensorCalibSettings) -> Bool {
    if lhs._runningFactor != rhs._runningFactor {return false}
    if lhs._calibType != rhs._calibType {return false}
    if lhs._runningFactorSource != rhs._runningFactorSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbStrideSensorCalibSettings.PbStrideCalibType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRIDE_CALIB_MANUAL"),
    1: .same(proto: "STRIDE_CALIB_AUTO"),
  ]
}

extension PbStrideSensorCalibSettings.PbRunningFactorSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNNING_FACTOR_SOURCE_DEFAULT"),
    1: .same(proto: "RUNNING_FACTOR_SOURCE_AUTO_CALIBRATION"),
    2: .same(proto: "RUNNING_FACTOR_SOURCE_MANUAL_CALIBRATION"),
  ]
}

extension PbWeek: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbWeek"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "week_number_ISO8601"),
    2: .same(proto: "year"),
    3: .standard(proto: "time_zone_offset"),
    4: .standard(proto: "week_start_day"),
  ]

  public var isInitialized: Bool {
    if self._weekNumberIso8601 == nil {return false}
    if self._year == nil {return false}
    if self._timeZoneOffset == nil {return false}
    if self._weekStartDay == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._weekNumberIso8601) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._year) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._timeZoneOffset) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._weekStartDay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._weekNumberIso8601 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._year {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeZoneOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._weekStartDay {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbWeek, rhs: PbWeek) -> Bool {
    if lhs._weekNumberIso8601 != rhs._weekNumberIso8601 {return false}
    if lhs._year != rhs._year {return false}
    if lhs._timeZoneOffset != rhs._timeZoneOffset {return false}
    if lhs._weekStartDay != rhs._weekStartDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSampleSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSampleSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_source_type"),
    2: .standard(proto: "start_index"),
    3: .standard(proto: "stop_index"),
  ]

  public var isInitialized: Bool {
    if self._sampleSourceType == nil {return false}
    if self._startIndex == nil {return false}
    if self._stopIndex == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleSourceType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._stopIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleSourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stopIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSampleSource, rhs: PbSampleSource) -> Bool {
    if lhs._sampleSourceType != rhs._sampleSourceType {return false}
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs._stopIndex != rhs._stopIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSensorCalibrationOffset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbSensorCalibrationOffset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_source_type"),
    2: .standard(proto: "speed_cal_offset"),
  ]

  public var isInitialized: Bool {
    if self._sampleSourceType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleSourceType) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._speedCalOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleSourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._speedCalOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbSensorCalibrationOffset, rhs: PbSensorCalibrationOffset) -> Bool {
    if lhs._sampleSourceType != rhs._sampleSourceType {return false}
    if lhs._speedCalOffset != rhs._speedCalOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbCalibrationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbCalibrationSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .standard(proto: "calibration_enabled"),
    3: .standard(proto: "calibration_calculation_enabled"),
  ]

  public var isInitialized: Bool {
    if self._sampleType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._calibrationEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._calibrationCalculationEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._calibrationEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._calibrationCalculationEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbCalibrationSettings, rhs: PbCalibrationSettings) -> Bool {
    if lhs._sampleType != rhs._sampleType {return false}
    if lhs._calibrationEnabled != rhs._calibrationEnabled {return false}
    if lhs._calibrationCalculationEnabled != rhs._calibrationCalculationEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbAccelerationMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbAccelerationMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_source_type"),
    2: .standard(proto: "calibration_settings"),
  ]

  public var isInitialized: Bool {
    if self._sampleSourceType == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.calibrationSettings) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleSourceType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.calibrationSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleSourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.calibrationSettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calibrationSettings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbAccelerationMetrics, rhs: PbAccelerationMetrics) -> Bool {
    if lhs._sampleSourceType != rhs._sampleSourceType {return false}
    if lhs.calibrationSettings != rhs.calibrationSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbAutoPause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbAutoPause"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trigger"),
    2: .standard(proto: "speed_threshold"),
  ]

  public var isInitialized: Bool {
    if self._trigger == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._trigger) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._speedThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trigger {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._speedThreshold {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbAutoPause, rhs: PbAutoPause) -> Bool {
    if lhs._trigger != rhs._trigger {return false}
    if lhs._speedThreshold != rhs._speedThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbAutoPause.PbAutoPauseTrigger: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO_PAUSE_OFF"),
    1: .same(proto: "AUTO_PAUSE_TRIGGER_SPEED"),
  ]
}

extension PbAutoLapSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbAutoLapSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "automatic_lap"),
    2: .standard(proto: "automatic_lap_distance"),
    3: .standard(proto: "automatic_lap_duration"),
  ]

  public var isInitialized: Bool {
    if self._automaticLap == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._automaticLap) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._automaticLapDistance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._automaticLapDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._automaticLap {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._automaticLapDistance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._automaticLapDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbAutoLapSettings, rhs: PbAutoLapSettings) -> Bool {
    if lhs._automaticLap != rhs._automaticLap {return false}
    if lhs._automaticLapDistance != rhs._automaticLapDistance {return false}
    if lhs._automaticLapDuration != rhs._automaticLapDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbAutoLapSettings.PbAutomaticLap: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AUTOMATIC_LAP_OFF"),
    2: .same(proto: "AUTOMATIC_LAP_DISTANCE"),
    3: .same(proto: "AUTOMATIC_LAP_DURATION"),
    4: .same(proto: "AUTOMATIC_LAP_LOCATION"),
  ]
}

extension PbCardioLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbCardioLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "activity_load"),
    2: .standard(proto: "exercise_load"),
  ]

  public var isInitialized: Bool {
    if self._activityLoad == nil {return false}
    if self._exerciseLoad == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._activityLoad) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._exerciseLoad) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activityLoad {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exerciseLoad {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbCardioLoad, rhs: PbCardioLoad) -> Bool {
    if lhs._activityLoad != rhs._activityLoad {return false}
    if lhs._exerciseLoad != rhs._exerciseLoad {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbPerceivedLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PbPerceivedLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_rpe"),
    2: .same(proto: "duration"),
  ]

  public var isInitialized: Bool {
    if self._sessionRpe == nil {return false}
    if self._duration == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sessionRpe) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionRpe {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PbPerceivedLoad, rhs: PbPerceivedLoad) -> Bool {
    if lhs._sessionRpe != rhs._sessionRpe {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
